Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії
 






Лабораторна робота
з дисципліни: «Архітектура програмного забезпечення»
на тему: «Розробка програмної архітектури та створення і відлагодження програмного коду програмного застосунку мобільного пристрою для програмної системи»
 



									Виконала: 	
									ст. гр. ПЗПІ-22-8	
									Кучерявенко К. Р.
									31 травня 2025 р.
									Перевірив:						 						Ст. викл. Сокорчук І. П.

                                                					


Харків 2025
4 РОЗРОБКА ПРОГРАМНОЇ АРХІТЕКТУРИ ТА СТВОРЕННЯ І ВІДЛАГОДЖЕННЯ ПРОГРАМНОГО КОДУ ПРОГРАМНОГО ЗАСТОСУНКУ МОБІЛЬНОГО ПРИСТРОЮ ДЛЯ ПРОГРАМНОЇ СИСТЕМИ
	4.1. Історія змін


Зміни в документі нотуються до таблиці 4.1.

Таблиця 4.1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	26.05.25	0.1	Створено розділ «Історія змін»
2	26.05.25	0.1	Створено розділ «Завдання»
3	26.05.25	0.1	Створено розділ «Опис виконаної роботи»
4	26.05.25	0.1	Створено розділ «Висновки»
5	31.05.25	0.1	Додано додаток А з посиланням на відеоролик
6	31.05.25	0.1	Додано додаток Б з графічними матеріалами
7	31.05.25	0.1	Додано додаток В з програмним кодом
			


4.2 Завдання


	Мета завдання – розробити частину системи, яка забезпечує підтримку роботи клієнтів на мобільній платформі Android. Програмний застосунок повинен мати зручний інтерфейс з необхідним функціоналом для користувача. Це включає доступ до записів, сортування, фільтрування, пошук, додавання, редагування й видалення існуючих записів. 
4.3 Опис виконаної роботи


Мобільний застосунок побудовано за спрощеною одноактивітійною архітектурою з використанням Jetpack Compose та механізму навігації через NavController. Усе UI-представлення реалізоване як набір Composable-функцій (екрани-скріни), кожен з яких відповідає окремому функціональному розділу (логін, реєстрація, головна сторінка, робота з донорами, біоматеріалами, умовами зберігання, сповіщеннями). Опишемо ключові шари.
UI-шар:
	–	екрани-вкладки, які реалізовані як Composable-функції;
	–	візуальні компоненти від Jetpack Compose (карточки, кнопки, текстові поля, тощо);
	–	управління станом здійснюється через remember і Compose State API;
–	навігація між екранами реалізована через NavController, який дозволяє перейти до того чи іншого екрану відповідно до маршруту.
Для мережевого шару використані бібліотеки Retrofit та Gson для обміну з серверним REST-API. Кожен сервіс описано як інтерфейс Retrofit. Усі запити до серверу (GET/POST/PUT/DELETE) описані через методи з відповідними анотаціями (@GET, @POST, @PUT, @DELETE). Використано Kotlin Coroutines у тих сервісах, де методи позначені як suspend, а в інших випадках — стандартний асинхронний виклик через enqueue(...) з Callback.
Локальне сховище (Local Storage) використовується для зберігання ідентифікатора користувача застосовано кастомний утилітний клас LocalStorage, який працює з SharedPreferences. Збереження userId відбувається після успішного входу та використовується при подальших CRUD-операціях, коли необхідно передати ідентифікатор користувача до серверу.
У проекті застосовано такі основні технології та компоненти:
–	мова програмування Kotlin;
–	Jetpack Compose (Android UI Toolkit);
–	Navigation Component для Compose;
–	Retrofit + Gson;
–	Kotlin Coroutines (suspend-функції);
–	Android SDK;
–	LocalStorage (SharedPreferences);
–	MaterialTheme (Material Design Components).
Застосунок працює як клієнтська частина єдиної системи, надаючи можливість кінцевому користувачеві взаємодіяти з бізнес-процесами, які реалізовані на сервері (REST-API). До бізнес-логіки належать такі операції як аутентифікація та реєстрація користувачів, перегляд, фільтрація та сортування інформації, CRUD – операції.  DonorsScreen відображає донорів у вигляді карток та містить логіку перевірки віку, де DatePickerDialog обмежує максимально можливе значення дати так, щоб донору було ≥ 18 років. BiologicalMaterialsScreen відображає інформацію про біоматеріал у форматі карток, що містять: назву, статус, дати, параметри температури/вологості/кисню, ім’я донора та групу крові. Кожна картка StorageConditionScreen показує: номер запису, опис і колір зони, значення температури, вологості, кисню, час виміру та назву матеріалу. Кожне сповіщення (NotificationScreen) містить тип події, деталі, час сповіщення (відформатований у dd.MM.yyyy HH:mm:ss) та назву матеріалу. На головній сторінці (HomeScreen) є кнопка “Logout”, яка при натисканні очищує навігаційний стек та повертає до екрану логіну.
Таким чином, бізнес-логіка полягає насамперед у CRUD-операціях з чотирма основними доменними сутностями (Donor, BiologicalMaterial, StorageCondition, Notification), завжди з передаванням userId як ідентифікатора користувача при модифікації даних.
На даний момент у проекті реалізовано базовий рівень захисту даних.
Аутентифікація: після введення логіну (e-mail) та пароля відправка відбувається через Retrofit до URL. Пароль передається у тілі POST-запиту (JSON із полями login та password).  Ідентифікатор користувача, який повертає сервер, зберігається в SharedPreferences (LocalStorage) з алгоритмом без шифрування. Усі модифікаційні операції (додавання, редагування, видалення) вимагають передачі userId у шляху (path parameter). Таким чином, сервер може перевірити, який користувач вніс зміни і о котрій годині. Використовується SharedPreferences для збереження ідентифікатора користувача (LocalStorage.setUserId). 
	Мобільний клієнт взаємодіє виключно з бекенд-сервісом через RESTful API, а також локально використовує SharedPreferences для збереження сесійного стану. Опишемо конкретні пункти взаємодії.
Для комунікації з сервером (Backend) використовується Retrofit для всіх HTTP-запитів. Усі доступні кінцеві точки сервера (REST-ресурси) підключені через різні ApiService-інтерфейси. Усі запити відправляються до єдиного серверного домену (http://10.0.2.2:8080/ при запуску в емуляторі), і відповіді JSON автоматично конвертуються в Kotlin-об’єкти через Gson.
Виконується збереження та отримання userId із SharedPreferences для передачі в URL CRUD-запитів. За відсутності userId локальне сховище повертає null, що може призводить до недоступності функцій.
У кожному екрані під час першої компоновки виконується асинхронний виклик до потрібного ApiService для отримання даних (списків). Після отримання даних місцевий стан оновлюється через mutableStateOf, і Compose автоматично перемальовує UI.
CRUD-операції (додавання, редагування, видалення) виконуються через launch із rememberCoroutineScope або enqueue-колбеки, після чого локально оновлюється список.
Для виводу всіх текстових елементів кожен рядок отримується через stringResource(R.string.some_key). Це дає можливість виносити тексти у файли для локалізації.
Отже, єдиний контакт із зовнішнім світом — REST-сервер. Умови зберігання, донори, біоматеріали, сповіщення весь час оновлюються і дістаються звідти. SharedPreferences використовується як засіб передачі сесійної інформації (userId) на бекенд.	
У проєкті застосовао стандартний механізм Android String Resources для інтернаціоналізації. У кожній Composable-функції для відображення тексту використовується Text (stringResource (R.string.ключ_рядка)) або stringResource(R.string.ключ_рядка, параметри…). Це гарантує, що залежно від налаштувань мови пристрою буде підібрано відповідний переклад із файлів strings.xml. У кореневому наборі рядків описані ключі для усіх підписів, кнопок, повідомлень про помилки, підказок. Застосунок підтримує дві мови: англійську та українську. Для відображення дати й часу використовується клас SimpleDateFormat із локаллю Locale.getDefault(). Це означає, що форматування дат автоматично підлаштовується під регіональні налаштування користувача. 
У мобільному застосунку передбачено базовий набір адміністративних операцій, реалізованих через CRUD-інтерфейси. Кожен запит на додавання, редагування або видалення передбачає передачу userId (Long), збереженого в SharedPreferences після логіну. Сервер визначає роль користувача. Якщо недостатня роль, сервер відмовить у виконанні операції. Адміністратор може створювати інших користувачів через екраниRegistration (SignUpScreen). За замовчуванням новий користувач має права лише для читання. Якщо поточний користувач має роль адміністратора, він отримує доступ до додавання / редагування інших сутностей (донорів, біоматеріалів).
Для кожної сутності передбачено елементи фільтрації (текстове поле, випадаючий список для групи крові/статусу/зони/матеріалу) та сортування (перемикач Asc/Desc). Це налаштування не зберігається між запусками застосунку: воно діє лише у поточній сесії кожного екрану.
Під час додавання/редагування донора/біоматеріалу передбачено вибір дати народження донора (із обмеженням мінімального віку 18 років) та дат передачі/придатності біоматеріалу/умов зберігання (з установкою відповідних мінімальних/максимальних значень).
У підсумку, функціональність налаштування та адміністрування полягає у
можливості CRUD‎-операцій над “Donor” та “BiologicalMaterial” для користувача з правами адміністратора, в обмеженої можливості фільтрації/сортування/пошуку без збереження налаштувань між запусками, базових діалогів підтвердження операцій (видалити) та вибору дати з базовою валідацією (вікові обмеження, діапазони дат), наявності “Logout” на головній сторінці для виходу та очищення навігаційного стеку.


	4.4 Висновки


У результаті створено мобільний застосунок на Kotlin із Jetpack Compose, який у межах однієї активності використовує NavController для навігації між екранами (логін, реєстрація, донори, біоматеріали, умови зберігання, сповіщення). Для обміну з бекендом застосовано Retrofit із Gson і Kotlin Coroutines (частково callbacks), що забезпечує CRUD-операції над сутностями Donor, BiologicalMaterial, StorageCondition і Notification. Після входу `userId` зберігається в SharedPreferences (LocalStorage) і передається до кожного запиту як маркер адміністративних прав. Базова валідація полів (порожні значення, діапазони дат і чисел) присутня, проте передача даних ідентифікатора та пароля здійснюється через HTTP без шифрування, шифроване сховище не використовується. Інтернаціоналізація закладена через `stringResource`, наразі є дві мови. Адміністратори можуть додавати, редагувати й видаляти записи, тоді як звичайні користувачі мають лише права читання, а клієнтська фільтрація й сортування реалізовані для кожного списку.


 
Додаток А
Хронологічний опис та посилання

Відеозапис доповіді на YouTube: https://youtu.be/fr0vkWpny94

Хронологічний опис доповіді:
00:00 Вступна частина
На самому початку доповіді відбувається коротке представлення, де оголошується тема ролику, яка зосереджена на тестуванні мобільного застосунку програмної системи.
00:09 Тестування: авторизація та мовна локалізація 
Перший функціональний блок присвячено перевірці сторінки авторизації. Вона зустрічає користувача відразу після запуску застосунку. На цьому екрані передбачено можливість швидкої зміни мови інтерфейсу за допомогою кнопки у верхній частині екрана. Якщо облікового запису ще немає, користувач може перейти до реєстрації через відповідне посилання на формі авторизації. Далі демонструється робота механізму динамічної зміни мови інтерфейсу. Після зміни мови з української на англійську всі елементи екрана авторизації адаптуються відповідно до вибраної мови. Після успішної авторизації застосунок переходить до демонстрації інших доступних сторінок, де перевіряється коректність перекладу англійськими рядками.
00:59 Тестування: загальний опис застосунку
Поки відбувається демонстрація перекладу, приділяється увага тому, що в мобільному застосунку відсутні моделі «Користувачі» та «Логування». Зазначається, що мобільний застосунок використовується як основна платформа для взаємодії із системою й розроблений так, щоб рівень входження був максимально низьким. Будь-яка людина, навіть без особливих технічних знань, може працювати з ним, керуючись лише інформацією, яка відображається на екрані.
01:26 Тестування: реєстрація
Перейшовши до блоку реєстрації, демонструється процес створення нового облікового запису. Для цього необхідно заповнити базові поля: ім’я, прізвище, логін та пароль. Після успішної реєстрації користувача автоматично перенаправляє на сторінку авторизації, де новостворений акаунт успішно увійшов у систему.
01:43 Тестування: домашня сторінка
Після авторизації користувач потрапляє на домашню сторінку, що містить п’ять кнопок. Перші чотири — це різні модулі взаємодії з даними системи (робота з таблицями «Біологічні матеріали», «Донори», «Умови зберігання» та «Повідомлення». П’ята кнопка відповідає за вихід з облікового запису.
01:54 Тестування: таблиця «Біологічні матеріали»
У модулі «Біологічні матеріали» доступний функціонал пошуку, фільтрації за групою крові й доступністю, а також кнопки для додавання нового матеріалу, редагування існуючих записів та видалення. Додатково передбачено можливість сортування записів за різними стовпцями. Демонструється процес створення нового матеріалу: на екрані з’являється форма з обов’язковими полями. Після заповнення всіх полів користувач натискає кнопку «Зберегти». Після створення демонструється робота функції редагування: обирають створений раніше запис, змінюють параметри й зберігають зміни. Наступним кроком показано, як видалити обраний матеріал.
02:45 Тестування: таблиця «Донори»
У модулі “Донори” передбачено перегляд усіх донорів, пошук за іменем і прізвищем, фільтрацію за групою крові, а також функції додавання, редагування й видалення записів донорів. Для додавання нового донора необхідно відкрити форму, де потрібно вказати перелік обов’язкових даних: ім’я, прізвище, дата народження, стать, унікальний ідентифікатор (наприклад, код паспорта) та групу крові. Важливо, щоб вік донора був більше за 18 років. Після заповнення всіх полів натискається «Зберегти». Далі демонстрація пошуку за ім’ям чи прізвищем та фільтрація за групою крові. Далі відбувається редагування вже існуючого запису. Потім через кнопку «Видалити» безповоротно видаляється запис донора із бази.
03:36 Тестування: таблиця «Повідомлення»
Перехід до модуля «Повідомлення». Тут видно список повідомлень, які формуються системою у випадку порушення умов зберігання біоматеріалів. Звертається увага на те, що через мобільний інтерфейс неможливо додавати, редагувати чи видаляти повідомлення — це доступне лише в веб-застосунку при наявності відповідних прав доступу. Проте присутня можливість фільтрації за назвою матеріалу та сортування повідомлень за часом (за зростанням або спаданням), що дозволяє легко знайти потрібну інформацію про попередження чи попередні сповіщення.
04:01 Тестування: таблиця «Умови зберігання»
Далі переходять до останньої вкладки «Умови зберігання». Дані сюди надходять автоматично кожні 5 секунд із підключених IoT-пристроїв. У цьому модулі вручну створювати чи видаляти записи неможливо — лише перегляд у режимі реального часу. На екрані відображаються актуальні показники температури, вологості та рівня кисню, поруч розміщено кольоровий індикатор, тобто зона (зелена, жовта чи червона), залежно від відповідності нормативним межам. Завдяки цьому користувач може миттєво оцінити стан умов зберігання: якщо якийсь параметр виходить за межі, індикатор змінює колір на жовтий або червоний. Доступні фільтрація за назвою матеріалу та назвою зони зберігання, а також сортування записів за часом для зручного аналізу історії показників. Підкреслюється, що в модулі «Умови зберігання» також можна переглянути історію зміни параметрів та використовувати фільтри для аналізу минулих записів. 
Додаток Б
Графічні матеріали


 
Рисунок Б.1 – UML діаграма прецедентів

 
Рисунок Б.2 – UML діаграма компонентів

 
Рисунок Б.3 – ER-модель даних мобільної платформи
     
Рисунок Б.4 – UML діаграма діяльності
 
Додаток В
Програмний код

	
В.1 Менеджер реєстрації
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab4/pzpi-22-8-kucheriavenko-kristina-lab4/screens/SignUpScreen.kt
1 class RegisterManager(
2     private val context: Context,
3     private val onError: (String) -> Unit
4 ) {
5     private val retrofit = Retrofit.Builder()
6         .baseUrl("http://10.0.2.2:8080")
7         .addConverterFactory(GsonConverterFactory.create())
8         .build()
9 
10     private val registerService = retrofit.create(RegisterService::class.java)
11 
12     fun register(
13         login: String,
14         firstName: String,
15         lastName: String,
16         password: String,
17         onSuccess: (SignupResponse) -> Unit
18     ) {
19         val signupRequest = SignupRequest(
20             login = login,
21             password = password,
22             first_name = firstName,
23             last_name = lastName
24         )
25 
26         registerService.register(signupRequest).enqueue(object : Callback<SignupResponse> {
27             override fun onResponse(
28                 call: Call<SignupResponse>,
29                 response: Response<SignupResponse>
30             ) {
31                 if (response.isSuccessful) {
32                     if (response.code() == 200) {
33                         onSuccess(SignupResponse(message = response.message()))
34                     } else {
35                         onError(
36                             context.getString(
37                                 R.string.error_signup_status,
38                                 response.message()
39                             )
40                         )
41                     }
42                 } else {
43                     onError(
44                         response.errorBody()?.string()
45                             ?: context.getString(R.string.error_signup)
46                     )
47                 }
48             }
49 
50             override fun onFailure(call: Call<SignupResponse>, t: Throwable) {
51                 onError(context.getString(R.string.error_network) + ": ${t.message}")
52             }
53         })
54     }
55 }

В.2 Ініціалізація та інтеграція системи перекладу
GitHub репозиторій: http://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab4/pzpi-22-8-kucheriavenko-kristina-lab4/MainActivity.kt 
1 val LocalAppLocale = compositionLocalOf { "uk" }
2 @Composable
3 fun ProvideAppLocale(content: @Composable () -> Unit) {
4     val locale = LocalAppLocale.current
5     val config = LocalConfiguration.current
6     val ctx = LocalContext.current
7 
8     SideEffect {
9         config.setLocale(Locale(locale))
10         ctx.resources.updateConfiguration(config, ctx.resources.displayMetrics)
11     }
12 
13     content()
14 }

В.3 Навігація між екранними маршрутизаторами
GitHub репозиторій: http://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab4/pzpi-22-8-kucheriavenko-kristina-lab4/MainActivity.kt 
1 NavHost(
2     navController = navController,
3     startDestination = "login",
4     modifier = Modifier.padding(innerPadding)
5 ) {
6     composable("login")         { LoginScreen(navController) }
7     composable("home")          { HomeScreen(navController) }
8     composable("signup")        { SignupScreen(navController) }
9     composable("materials")     { BiologicalMaterialsScreen(navController) }
10     composable("notifications") { NotificationsScreen(navController) }
11     composable("donors")        { DonorsScreen(navController) }
12     composable("storageConditions") {
13         StorageConditionalsScreen(navController)
14     }
15 }


