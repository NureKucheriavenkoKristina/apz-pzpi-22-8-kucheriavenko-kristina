Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії
 






Лабораторна робота №2
з дисципліни: «Архітектура програмного забезпечення»
 





 
Виконала: 								Перевірив:
ст. гр. ПЗПІ-22-8							Ст. в. Сокорчук І. П. 
Кучерявенко К. Р.

                                                					





Харків 2025
2 РОЗРОБКА ПРОГРАМНОЇ АРХІТЕКТУРИ, СТВОРЕННЯ ТА
ВІДЛАГОДЖЕННЯ ПРОГРАМНОГО КОДУ СЕРВЕРНОЇ ЧАСТИНИ
ПРОГРАМНОЇ СИСТЕМИ
2.1. Історія змін


Зміни в документі нотуються до таблиці 2.1.

Таблиця 2.1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	03.05.25	0.1	Створено розділ «Історія змін»
2	03.05.25	0.1	Створено розділ «Завдання»
3	03.05.25	0.1	Створено розділ «Опис виконаної роботи»
4	03.05.25	0.1	Створено розділ «Висновки»
5	03.05.25	0.1	Додано додаток А з посиланням на відеоролик
6	03.05.25	0.1	Додано додаток Б з графічними матеріалами
7	03.05.25	0.1	Додано додаток В з програмним кодом
8	03.05.25	0.1	Додано додаток Г з специфікацію REST


2.2 Завдання


	Мета завдання – розробити серверну (back-end) частину програмної системи, що забезпечує повноцінне управління даними користувачів, реалізацію бізнес-логіки, взаємодію з базою даних та зовнішніми сервісами, а також підтримує масштабування та безпеку. У рамках завдання необхідно спроєктувати архітектуру серверної частини, реалізувати REST API, обрати відповідні програмні технології, провести функціональне тестування та описати прийняті інженерні рішення.

2.3 Опис виконаної роботи


Програмна система є серверною частиною інформаційної системи управління біологічними матеріалами. Вона розроблена для забезпечення зберігання, обліку, обробки та контролю за біологічними матеріалами та пов’язаними з ними даними. Система підтримує три рівні доступу користувачів: звичайний, частковий та повний, кожен з яких має власний набір дозволених дій відповідно до ролі.
Архітектура програмної системи реалізована відповідно до принципів багаторівневої архітектури (three-tier architecture), з чітким розділенням на:
–	контролери (Controller): приймають HTTP-запити, викликають відповідні сервіси та повертають відповіді клієнту;
–	сервіси (Service): реалізують бізнес-логіку та взаємодіють із репозиторіями;
–	репозиторії (Repository): відповідають за доступ до бази даних (PostgreSQL), використовуючи ORM (Spring Data JPA).
Архітектурний стиль взаємодії між компонентами реалізований за допомогою REST API, що дозволяє зручно та стандартизовано обмінюватися даними з іншими системами або майбутніми клієнтськими застосунками (веб та мобільним інтерфейсом).
Серверна частина побудована з використанням мови Java та фреймворку Spring Boot, що забезпечує гнучкість, модульність та високу швидкість розробки. Основними модулями системи є:
–	модуль управління біоматеріалами: облік, реєстрація, редагування, видалення біоматеріалів;
–	модуль донорів: зберігання та обробка інформації про донорів;
–	модуль логування: фіксація дій користувачів і подій у системі;
–	модуль сповіщень: надсилання системних повідомлень користувачам;

–	модуль звітів: формування та збереження звітів за вибраними параметрами;
–	модуль умов зберігання: визначення температурного режиму, вологості, строків тощо;
–	модуль користувачів: реєстрація, авторизація, призначення ролей та керування доступом.
Завдяки гнучкості архітектури та модульному підходу система легко масштабується, підтримує розширення функціональності, а також спрощує супровід і тестування. Кожен з модулів є ізольованим з погляду логіки, але може взаємодіяти з іншими через сервісний рівень.
Математичні методи обробки даних використовуються під час логування змін у таблиці з умовами зберігання. При отриманні даних про температуру, вологість та кисень, система підраховує середнє значення всіх показників за цим матеріалом і відхилення останнього показника від середнього значення. Це надає змогу контролювати стан матеріалу та вчасно відкоригувати його умови зберігання. 
Формула для середнього значення: 
x ̅=1/n ∑_(l ̇=1)^n▒x_i ,
де x ̅ – середнє значення, x_i –  кожне значення в наборі даних, n – кількість елементів у наборі даних.
Формула відхилення останнього показника від середнього значення:
d_i=x_i-x ̅,
де d_i – відхилення i-го елемента від середнього значення, x_i –  останнє значення показника, x ̅ – середнє значення.
База даних проєкту реалізована у системі керування базами даних PostgreSQL та побудована відповідно до предметної області управління біологічними матеріалами. Вона включає сім основних таблиць, які відповідають основним модулям системи. Для кожної таблиці чітко визначено атрибути, типи даних, зв’язки з іншими таблицями, а також умови заповнення полів та обмеження цілісності даних. Нижче подано опис основних таблиць та їхніх полів.
Таблиця BiologicalMaterials:
–	materialID унікальний ідентифікатор запису, генерується автоматично;
–	materialName обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	expirationDate обов’язкове поле, дата має бути у майбутньому;
–	status обов’язкове поле, перелічуваний тип даних, значення, окрім визначених у переліку, не дозволяються;
–	transferDate обов’язкове поле, дата, яка має бути у минулому або сьогоденні;
–	donorID обов’язкове поле, зв’язок з таблицею Donors, не може бути пустим.
Таблиця Donors:
–	donorID унікальний ідентифікатор донора, генерується автоматично;
–	firstName обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	lastName обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	birthDate обов’язкове поле, дата, яка має бути у минулому;
–	gender обов’язкове поле, перелічуваний тип даних, значення, окрім визначених у переліку, не дозволяються;
–	idNumber обов’язкове поле, унікальний ідентифікатор донора, що відповідає шаблону з 10 латинських літер та цифр;
–	bloodType обов’язкове поле, перелічуваний тип даних для групи крові;
–	transplantRestrictions необов’язкове поле, рядок до 500 символів, може залишатися пустим.
Таблиця EventLogs:
–	eventLogID унікальний ідентифікатор запису, генерується автоматично;
–	actionDetails обов’язкове поле, рядок довжиною від 2 до 1000 символів, не може бути пустим;
–	actionTime обов’язкове поле, дата має бути у минулому або сьогоденні;
–	creatorID обов’язкове поле, зв’язок з таблицею Users, не може бути пустим.
Таблиця Notifications:
–	notificationID унікальний ідентифікатор запису, генерується автоматично;
–	eventTime обов’язкове поле, дата має бути у минулому або сьогоденні;
–	eventType обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	details обов’язкове поле, рядок довжиною від 5 до 500 символів, не може бути пустим;
–	status обов’язкове поле, рядок довжиною від 2 до 50 символів, не може бути пустим;
–	materialID обов’язкове поле, зв’язок з таблицею BiologicalMaterials, не може бути пустим.
Таблиця Reports:
–	reportID унікальний ідентифікатор запису, генерується автоматично;
–	reportType обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	creationDate обов’язкове поле, дата, яка має бути у минулому або сьогоденні;
–	text обов’язкове поле, рядок довжиною від 5 до 1000 символів, не може бути пустим;
–	fileLink обов’язкове поле, унікальний рядок довжиною від 5 до 500 символів, не може бути пустим;
–	eventLogID обов’язкове поле, зв’язок з таблицею EventLogs, не може бути пустим.
Таблиця StorageCondition:
–	recordID унікальний ідентифікатор запису, генерується автоматично;
–	temperature обов’язкове поле, числове значення у межах від -100 до 100;
–	oxygenLevel обов’язкове поле, числове значення у межах від 0 до 100;
–	humidity обов’язкове поле, числове значення у межах від 0 до 100;
–	measurementTime обов’язкове поле,  дата має бути у минулому або сьогоденні;
–	materialID обов’язкове поле, зв’язок з таблицею BiologicalMaterials, не може бути пустим.
Таблиця Users:
–	userID унікальний ідентифікатор запису, генерується автоматично;
–	firstName обов’язкове поле, рядок довжиною від 2 до 255 символів, не може бути пустим;
–	lastName обов’язкове поле, рядок довжиною від 2 до 255 символів, не може бути пустим;
–	role обов’язкове поле, рядок довжиною від 2 до 255 символів, не може бути пустим;
–	accessRights поле містить значення за умовчанням, перелічуваний тип даних, не може бути пустим;
–	login обов’язкове поле, унікальний рядок довжиною від 2 до 100 символів, форматоване як email;
–	password обов’язкове поле, рядок довжиною не менше 6 символів, не може бути пустим.
Специфікація REST знаходиться у додатку Г.
У розробці серверної частини програмної системи управління біологічними матеріалами використано сучасні, надійні та масштабовані технології, що забезпечують чітку архітектуру, безпеку та зручність супроводу проєкту. Мова програмування Java 22, обрана за свою стабільність, підтримку великої спільноти та сумісність із Spring Framework. Фреймворк: Spring Boot, дозволяє швидко створювати готові до продакшну REST-сервіси з вбудованим веб-сервером та автоматизованою конфігурацією. Архітектура: MVC (Model–View–Controller). Серверна частина реалізована за принципом Controller → Service → Repository, що забезпечує модульність та розділення обов’язків. ORM: Spring Data JPA (на базі Hibernate) Дозволяє взаємодіяти з базою даних PostgreSQL через об’єктно-реляційне відображення. База даних: PostgreSQL, потужна, відкрита реляційна СУБД з широкими можливостями, що добре підходить для зберігання структурованих медичних і користувацьких даних. Валідація: Jakarta Bean Validation (раніше Hibernate Validator). Застосовується для перевірки вхідних даних у моделях (наприклад, @NotNull, @Size, @Email, @Pattern тощо). Усі запити обробляються через REST-контролери (@RestController), які обслуговують клієнтів JSON-відповідями.
На поточному етапі реалізації система не підтримує інтерналізацію (I18N), тобто зміна мови відповіді для різних локалей не реалізована.
Нижче наведені основні компоненти реалізації.
Контролери (@RestController) – реалізують обробку HTTP-запитів від клієнтської частини. Для кожної сутності (наприклад, BiologicalMaterialsController, DonorsController) створено окремий REST-контролер з методами CRUD (GET, POST, PUT, DELETE).
Сервіси (@Service) – містять бізнес-логіку. У сервісах реалізується перевірка умов (наприклад, чи існує донор, чи дата дійсна), виклики репозиторіїв і обробка результатів.
Репозиторії (@Repository, інтерфейси, що наслідують JpaRepository) – відповідають за взаємодію з базою даних. Для кожної сутності створено окремий репозиторій.
Сутності (@Entity) – кожна таблиця в базі даних має відповідну модель у вигляді Java-класу з анотаціями (@Column, @NotNull, @Pattern, @Enumerated тощо), які описують правила зберігання та валідації даних.
Валідація даних – за допомогою jakarta.validation (@Valid, @NotBlank, @Size, @Past, @Future, @Pattern) забезпечується перевірка вхідних даних до обробки логіки.
Функціональне тестування проводилося з використанням Postman –популярного інструменту для роботи з API-запитами. Основні етапи тестування включали запуск локального сервера Spring Boot (localhost:8080), імпорт колекції запитів Postman для кожного з ресурсів (/donors, /materials, /reports, тощо), перевірка коректності CRUD-операцій, тестування валідації, тестування зв’язків між таблицями та унікальності. 


2.4 Висновки 


	У ході виконаної роботи було успішно реалізовано серверну частину інформаційної системи управління біологічними матеріалами, яка базується на багаторівневій архітектурі з чітким розподілом відповідальностей між компонентами. Система забезпечує надійне зберігання, обробку та контроль біоматеріалів, а також підтримує диференційований доступ для користувачів з різними ролями. Завдяки використанню фреймворку Spring Boot, ORM Spring Data JPA та бази даних PostgreSQL досягнуто високої продуктивності, гнучкості й масштабованості. Особливу увагу приділено модульності системи, логуванню дій, аналітиці умов зберігання за допомогою математичних методів та стандартизованому REST API для інтеграції з іншими сервісами. Таким чином, створена програмна система є надійною платформою для подальшого розвитку, інтеграції та розширення функціональних можливостей. 

Додаток А
	ВІДЕОЗАПИС

	Відеозапис доповіді на YouTube: https://youtu.be/VWnLnIFwC6k

	Відеозапис доповіді на YouTube: https://youtu.be/cunWqrs81rM

	Відеозапис презентації результатів лабораторної роботи: https://youtu.be/cunWqrs81rM

	Хронологічний опис доповіді:
	00:00 Вступна частина
	Короткий вступ, у якому пояснюється, про що буде ролик.
	00:20 Тестування: біоматеріали
	Показано тестування API для біоматеріалів:
	–	створення через POST-запит із перевіркою ролі користувача;
	–	отримання одного матеріалу по ID через GET-запит;
	–	отримання всіх матеріалів через GET-запит;
	–	оновлення з перевіркою коректності даних через PUT-запит;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	00:59 Тестування: донори
	Показано тестування API для донорів:
	–	створення через POST-запит із перевіркою ролі користувача;
	–	отримання одного донора по ID через GET-запит;
	–	отримання всіх донорів через GET-запит;
	–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	01:45 Тестування: логування
	Показано тестування API для логування:
	–	створення через POST-запит із валідацією користувача із перевіркою ролі користувача, доступ лише за ролі FULL;
	–	отримання один запис логування по ID через GET-запит із перевіркою ролі користувача;
	–	отримання всі записи логування через GET-запит із перевіркою ролі користувача;
	–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	02:35 Тестування: сповіщення
	Показано тестування API для сповіщень:
	–	створення через POST-запит із валідацією користувача із перевіркою ролі користувача;
	–	отримання одного запису сповіщення по ID через GET-запит;
	–	отримання всіх записів сповіщень через GET-запит;
	–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	03:15 Тестування: звіти
	Показано тестування API для звітів:
	–	створення через POST-запит із валідацією користувача;
	–	отримання одного звіту по ID через GET-запит;
	–	отримання всіх звітів через GET-запит;
	–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	03:59 Тестування: умови зберігання
	Показано тестування API для умов зберігання:
	–	створення через POST-запит із валідацією користувача із перевіркою ролі користувача;
	–	отримання одного запису умов зберігання по ID через GET-запит;
	–	отримання всіх записів умов зберігання через GET-запит;
	–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	04:56 Тестування: користувачі
	Показано тестування API для користувачів:
	–	створення через POST-запит звичайного користувача;
	–	створення через POST-запит користувача з певними правами доступу;
	–	отримання одного користувача по ID через GET-запит;
	–	отримання всіх користувачів через GET-запит;
	–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;;
	–	видалення через DELETE-запит із перевіркою ролі користувача.
	06:11 Тестування: автоматичне створення бекапу за розкладом
	Перегляд папки «db» та відсутність в ній файлі. Відбувається запуск серверу. Продемонстровано автоматичне створення бекапу за розкладом «кожні 10 сек». В консолі виводиться текст про успішність (або помилку). Демонстрація папки «db» з щойно створеними бекапами бази даних. 

 
Додаток Б
Графічні матеріали


 
Рисунок Б.1 – UML діаграма розгортання

 
Рисунок Б.2 – UML діаграма прецедентів
 
Рисунок Б.3 – ER-модель даних

 
Рисунок Б.4 – UML діаграма взаємодії
 
Додаток В
Програмний код

	В.1 Математична обробка прикладних даних
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/service/StorageConditionService.java

1. private String logMessage(StorageCondition condition, String creator) {
2.     Map<String, Double> averages = calculateAverageValues(condition.getMaterialID().getMaterialID());
3.     double temperatureDeviation = condition.getTemperature() - averages.getOrDefault("avgTemperature", 0.0);
4.     double oxygenLevelDeviation = condition.getOxygenLevel() - averages.getOrDefault("avgOxygenLevel", 0.0);
5.     double humidityDeviation = condition.getHumidity() - averages.getOrDefault("avgHumidity", 0.0);
6. 
7.     return String.format(
8.             "Added new storage condition by %s and material with ID: %d | " +
9.                     "Averages - Temperature: %.2f°C (Deviation: %.2f°C), " +
10.                     "Oxygen Level: %.2f%% (Deviation: %.2f%%), " +
11.                     "Humidity: %.2f%% (Deviation: %.2f%%)",
12.             creator,
13.             condition.getRecordID(),
14.             averages.getOrDefault("avgTemperature", 0.0),
15.             temperatureDeviation,
16.             averages.getOrDefault("avgOxygenLevel", 0.0),
17.             oxygenLevelDeviation,
18.             averages.getOrDefault("avgHumidity", 0.0),
19.             humidityDeviation
20.     );
21. }
22. 
23. public Map<String, Double> calculateAverageValues(Long materialId) {
24.     List<Object[]> averages = repository.findAverageValuesByMaterialId(materialId);
25.     Map<String, Double> averagesMap = new HashMap<>();
26.     if (averages != null && !averages.isEmpty()) {
27.         Object[] avgValues = averages.get(0);
28.         averagesMap.put("avgTemperature", (Double) avgValues[0]);
29.         averagesMap.put("avgOxygenLevel", (Double) avgValues[1]);
30.         averagesMap.put("avgHumidity", (Double) avgValues[2]);
31.     }
32.     return averagesMap;
33. }

В.2 Резервне копіювання користувацьких даних (кожен день о 4:00)
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/config/BackupService.java

1. @Service
2. public class BackupService {
3. 
4.     @Value("${backup.path}")
5.     private String backupPath;
6.     @Value("${spring.datasource.password}")
7.     private String password;
8. 
9.     @Scheduled(cron = "0 0 4 * * *")
10.     public void performBackup() {
11.         if (backupPath == null) {
12.             System.err.println("Path is null");
13.             return;
14.         }
15. 
16.         File backupDir = new File(backupPath);
17.         if (!backupDir.exists()) {
18.             boolean created = backupDir.mkdirs();
19.             if (!created) {
20.                 System.err.println("Failed to create backup directory");
21.                 return;
22.             }
23.         }
24. 
25.         String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
26.         String fileName = "backup_" + timestamp + ".sql";
27.         File backupFile = new File(backupDir, fileName);
28. 
29.         try {
30.             ProcessBuilder pb = new ProcessBuilder(
31.                     "C:\\Program Files\\PostgreSQL\\17\\bin\\pg_dump.exe",
32.                     "-U", "postgres",
33.                     "-F", "c",
34.                     "-f", backupFile.getAbsolutePath(),
35.                     "system-for-managing-medical-biological-materials"
36.             );
37. 
38.             pb.environment().put("PGPASSWORD", password);
39. 
40.             Process process = pb.start();
41.             int exitCode = process.waitFor();
42. 
43.             BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
44.             String line;
45.             while ((line = reader.readLine()) != null) {
46.                 System.err.println(line);
47.             }
48. 
49.             if (exitCode == 0) {
50.                 System.out.println("Backup successfully created");
51.             } else {
52.                 System.err.println("Error creating backup. Code: " + exitCode);
53.             }
54. 
55.         } catch (Exception e) {
56.             e.printStackTrace();
57.         }
58.     }
59. }

В.3 Модель «Донор»
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/model/Donor.java
1. @Entity
2. @Table(name = "donors")
3. @Getter
4. @Setter
5. public class Donor {
6. 
7.     @Id
8.     @GeneratedValue(strategy = GenerationType.IDENTITY)
9.     private Long donorID;
10. 
11.     @NotNull(message = "First name cannot be null")
12.     @Size(min = 2, max = 100, message = "First name must be between 2 and 100 characters")
13.     @Column(nullable = false)
14.     private String firstName;
15. 
16.     @NotNull(message = "Last name cannot be null")
17.     @Size(min = 2, max = 100, message = "Last name must be between 2 and 100 characters")
18.     @Column(nullable = false)
19.     private String lastName;
20. 
21.     @NotNull(message = "Birth date cannot be null")
22.     @Past(message = "Birth date must be in the past")
23.     @Column(nullable = false)
24.     private Date birthDate;
25. 
26.     @NotNull(message = "Gender cannot be null")
27.     @Enumerated(EnumType.STRING)
28.     @Column(nullable = false)
29.     private Gender gender;
30. 
31.     @NotNull(message = "ID number cannot be null")
32.     @Pattern(regexp = "^[A-Za-z0-9]{10}$", message = "ID number must be 10 digits long")
33.     @Column(nullable = false, unique = true)
34.     private String idNumber;
35. 
36.     @NotNull(message = "Blood type cannot be null")
37.     @Enumerated(EnumType.STRING)
38.     @Column(nullable = false)
39.     private RhFactorOfBlood bloodType;
40. 
41.     @Size(max = 500, message = "Transplant restrictions cannot exceed 500 characters")
42.     @Column(nullable = false)
43.     private String transplantRestrictions;
44. }

В.4 Контролер «Донор»
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/controllers/DonorController.java

1. @RestController
2. @RequiredArgsConstructor
3. @RequestMapping("/api/donors")
4. public class DonorController {
5.     private final DonorService donorService;
6.     private final UserService userService;
7. 
8.     @PostMapping("/admin/{userId}/add")
9.     public ResponseEntity<Donor> createDonor(
10.             @PathVariable("userId") Long userId,
11.             @Valid @RequestBody Donor donor,
12.             BindingResult result) {
13. 
14.         if (result.hasErrors()) {
15.             return ResponseEntity.badRequest().body(null);
16.         }
17. 
18.         User user = userService.getUserById(userId);
19.         if (user == null) {
20.             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
21.         }
22. 
23.         if (!userService.availabilityOfAction(userId)) {
24.             return ResponseEntity.status(HttpStatus.FORBIDDEN).body(null);
25.         }
26. 
27.         donorService.createDonor(user, donor);
28. 
29.         return ResponseEntity.ok(donor);
30.     }
31. 
32.     @GetMapping("/{DonorID}")
33.     public ResponseEntity<Donor> getDonorById(@PathVariable("DonorID") Long id) {
34.         Donor donor = donorService.getDonorById(id);
35.         if (donor == null) {
36.             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
37.         }
38.         return ResponseEntity.ok(donor);
39.     }
40. 
41.     @GetMapping
42.     public ResponseEntity<List<Donor>> getAllDonors() {
43.         return ResponseEntity.ok(donorService.getAllDonors());
44.     }
45. 
46.     @PutMapping("/admin/{userId}/{DonorID}")
47.     public ResponseEntity<Donor> updateDonor(
48.             @PathVariable("userId") Long userId,
49.             @PathVariable("DonorID") Long id,
50.             @Valid @RequestBody Donor donor,
51.             BindingResult result) {
52. 
53.         if (result.hasErrors()) {
54.             return ResponseEntity.badRequest().body(null);
55.         }
56. 
57.         User user = userService.getUserById(userId);
58.         if (user == null) {
59.             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
60.         }
61. 
62.         if (!userService.availabilityOfAction(userId)) {
63.             return ResponseEntity.status(HttpStatus.FORBIDDEN).body(null);
64.         }
65. 
66.         donorService.updateDonor(user, id, donor);
67. 
68.         return ResponseEntity.ok(donor);
69.     }
70. 
71.     @DeleteMapping("/admin/{userId}/{id}")
72.     public ResponseEntity<Void> deleteDonor(
73.             @PathVariable("userId") Long userId,
74.             @PathVariable("id") Long id) {
75. 
76.         User user = userService.getUserById(userId);
77.         if (user == null) {
78.             return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
79.         }
80. 
81.         if (!userService.availabilityOfAction(userId)) {
82.             return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
83.         }
84. 
85.         donorService.deleteDonor(user, id);
86. 
87.         return ResponseEntity.noContent().build();
88.     }
89. }


В.5 Сервіс «Донор»
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/service/DonorService.java

1. @Service
2. @RequiredArgsConstructor
3. public class DonorService {
4.     private final DonorRepository donorRepository;
5.     private final EventLogService eventLogService;
6. 
7.     public void createDonor(User user, Donor donor) {
8.         donorRepository.save(donor);
9.         eventLogService.logAction(user, "Added a new donor with an ID: " + donor.getDonorID());
10.     }
11. 
12.     public Donor getDonorById(Long id) {
13.         return donorRepository.findById(id)
14.                 .orElseThrow(() -> new RuntimeException("Donor not found"));
15.     }
16. 
17.     public List<Donor> getAllDonors() {
18.         return donorRepository.findAll();
19.     }
20. 
21.     public void updateDonor(User user, Long id, Donor newDonor) {
22.         Donor donor = getDonorById(id);
23.         donor.setFirstName(newDonor.getFirstName());
24.         donor.setLastName(newDonor.getLastName());
25.         donor.setBirthDate(newDonor.getBirthDate());
26.         donor.setGender(newDonor.getGender());
27.         donor.setIdNumber(newDonor.getIdNumber());
28.         donor.setBloodType(newDonor.getBloodType());
29.         donor.setTransplantRestrictions(newDonor.getTransplantRestrictions());
30.         donorRepository.save(donor);
31.         eventLogService.logAction(user, "Updated donor with an ID: " + donor.getDonorID());
32.     }
33. 
34.     public void deleteDonor(User user, Long id) {
35.         Long copyId = id;
36.         donorRepository.deleteById(id);
37.         eventLogService.logAction(user, "Deleted donor with an ID: " + copyId);
38.     }
39. }

В.6 Репозиторій «Умови зберігання»
Репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/repository/StorageConditionRepository.java

1. @Repository
2. public interface StorageConditionRepository extends JpaRepository<StorageCondition, Long> {
3. 
4.     @Query("SELECT AVG(sc.temperature), AVG(sc.oxygenLevel), AVG(sc.humidity) " +
5.             "FROM StorageCondition sc " +
6.             "WHERE sc.materialID.id = :materialId")
7.     List<Object[]> findAverageValuesByMaterialId(Long materialId);
8. }
 
Додаток Г
Специфікація REST


# API Документація для проєкту "Програмна система для управлінням медичними біологічними матеріалами"

API забезпечує функціональність для управління медичними біологічними матеріалами. Він дозволяє реєструвати, відстежувати та аналізувати матеріали, забезпечуючи інтеграцію з IoT пристроями для моніторингу умов зберігання.

## Контролери 

# BiologicalMaterialController API

## Маршрути

### Add Biological Material

**POST** '/api/biological-materials/admin/{userId}/add'

#### Опис

Додає новий біологічний матеріал від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

Body:
- materialName (String): Назва біологічного матеріалу.
- expirationDate (Date): Дата закінчення терміну придатності.
- status (String): Статус донорства.
- transferDate (Date): Дата передачі матеріалу.
- donorID (Long): Ідентифікатор донора.

#### Відповідь 

- 200 OK:
  - BiologicalMaterial (object): Об'єкт створеного матеріалу.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Biological Material By ID

**GET** '/api/biological-materials/{materialID}'

#### Опис

Отримує біологічний матеріал за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- materialID (Long): Ідентифікатор матеріалу.

#### Відповідь 

- 200 OK:
  - BiologicalMaterial (object): Біологічний матеріал за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що матеріал не знайдено.

### Get All Biological Materials

**GET** '/api/biological-materials'

#### Опис

Отримує всі біологічні матеріали.

#### Параметри запиту
Path:
- materialID (Long): Ідентифікатор матеріалу.

#### Відповідь 

- 200 OK:
  - List<BiologicalMaterial> (Array): Список усіх біологічних матеріалів.


### Update Biological Material

**PUT** '/api/biological-materials/admin/{userId}/{materialID}'

#### Опис

Оновлює існуючий біологічний матеріал від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- materialID (Long): Ідентифікатор матеріалу, який потрібно оновити.
  
Body:
- materialName (String): Назва біологічного матеріалу.
- expirationDate (Date): Дата закінчення терміну придатності.
- status (String): Статус донорства.
- transferDate (Date): Дата передачі матеріалу.
- donorID (Long): Ідентифікатор донора.

#### Відповідь 

- 200 OK:
  - BiologicalMaterial (Object): Оновлений біологічний матеріал.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що матеріал не знайдено.

### Delete Biological Material

**DELETE** '/api/biological-materials/admin/{userId}/{materialID}'

#### Опис

Видаляє біологічний матеріал від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- materialID (Long): Ідентифікатор матеріалу, який потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення матеріалу відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що матеріал не знайдено.

# DonorController API

## Маршрути

### Add Donor

**POST** '/api/donors/admin/{userId}/add'

#### Опис

Додає нового донора від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

Body:
- firstName (String): Ім'я донора.
- lastName (String): Прізвище донора.
- birthDate (Date): Дата народження донора.
- gender (Gender): Стать донора.
- idNumber (String): Ідентифікаційний номер донора.
- bloodType (RhFactorOfBlood): Група крові донора.
- transplantRestrictions (String): Обмеження на трансплантацію.

#### Відповідь 

- 200 OK:
  - Donor (object): Об'єкт створеного донора.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Donor By ID

**GET** '/api/donors/{DonorID}'

#### Опис

Отримує інформацію про донора за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- DonorID (Long): Ідентифікатор донора.

#### Відповідь 

- 200 OK:
  - Donor (object): Донор за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що донор не знайдений.

### Get All Donors

**GET** '/api/donors'

#### Опис

Отримує список усіх донорів.

#### Відповідь 

- 200 OK:
  - List<Donor> (Array): Список усіх донорів.

### Update Donor

**PUT** '/api/donors/admin/{userId}/{DonorID}'

#### Опис

Оновлює існуючого донора від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- DonorID (Long): Ідентифікатор донора, якого потрібно оновити.
  
Body:
- firstName (String): Ім'я донора.
- lastName (String): Прізвище донора.
- birthDate (Date): Дата народження донора.
- gender (Gender): Стать донора.
- idNumber (String): Ідентифікаційний номер донора.
- bloodType (RhFactorOfBlood): Група крові донора.
- transplantRestrictions (String): Обмеження на трансплантацію.

#### Відповідь 

- 200 OK:
  - Donor (Object): Оновлений об'єкт донора.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що донор не знайдений.

### Delete Donor

**DELETE** '/api/donors/admin/{userId}/{id}'

#### Опис

Видаляє донора від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор донора, якого потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення донора відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що донор не знайдений.

# EventLogController API

## Маршрути

### Add Event Log

**POST** '/api/event-logs/admin/{userId}/add'

#### Опис

Додає новий запис про подію від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:

#### Відповідь 

- 200 OK:
  - EventLog (object): Об'єкт створеного запису про подію.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Event Log By ID

**GET** '/api/event-logs/admin/{userId}/{id}'

#### Опис

Отримує запис про подію за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор запису.

#### Відповідь 

- 200 OK:
  - EventLog (object): Запис про подію за вказаним ідентифікатором.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Запис не знайдено.

### Get All Event Logs

**GET** '/api/event-logs/admin/{userId}'

#### Опис

Отримує всі записи про події.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

#### Відповідь 

- 200 OK:
  - List<EventLog> (Array): Список всіх записів про події.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.

### Update Event Log

**PUT** '/api/event-logs/admin/{userId}/{id}'

#### Опис

Оновлює існуючий запис про подію від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор запису, який потрібно оновити.
  
Body:
- actionDetails (String): Деталі дії.
- actionTime (Date): Час виконання дії.

#### Відповідь 

- 200 OK:
  - EventLog (Object): Оновлений запис про подію.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Запис не знайдено.

### Delete Event Log

**DELETE** '/api/event-logs/admin/{userId}/{id}'

#### Опис

Видаляє запис про подію від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор запису, який потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення запису про подію відбулося успішно.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Запис не знайдено.
 
# NotificationController API

## Маршрути

### Add Notification

**POST** '/api/notifications/admin/{userId}/add'

#### Опис

Додає нове сповіщення від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:
- eventTime (Date): Час події.
- eventType (String): Тип події.
- details (String): Деталі сповіщення.
- status (String): Статус сповіщення.
- materialID (BiologicalMaterial): Біологічний матеріал, що пов'язаний зі сповіщенням.

#### Відповідь 

- 200 OK:
  - Notification (object): Об'єкт створеного сповіщення.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Notification By ID

**GET** '/api/notifications/{id}'

#### Опис

Отримує сповіщення за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор сповіщення.

#### Відповідь 

- 200 OK:
  - Notification (object): Сповіщення за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що сповіщення не знайдено.

### Get All Notifications

**GET** '/api/notifications'

#### Опис

Отримує список усіх сповіщень.

#### Відповідь 

- 200 OK:
  - List<Notification> (Array): Список усіх сповіщень.

### Update Notification

**PUT** '/api/notifications/admin/{userId}/{id}'

#### Опис

Оновлює існуюче сповіщення від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор сповіщення, яке потрібно оновити.
  
Body:
- eventTime (Date): Час події.
- eventType (String): Тип події.
- details (String): Деталі сповіщення.
- status (String): Статус сповіщення.
- materialID (BiologicalMaterial): Біологічний матеріал, що пов'язаний зі сповіщенням.

#### Відповідь 

- 200 OK:
  - Notification (Object): Оновлений об'єкт сповіщення.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що сповіщення не знайдено.

### Delete Notification

**DELETE** '/api/notifications/admin/{userId}/{id}'

#### Опис

Видаляє сповіщення від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор сповіщення, яке потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення сповіщення відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що сповіщення не знайдено.

# ReportController API

## Маршрути

### Add Report

**POST** '/api/reports/admin/{userId}/add'

#### Опис

Додає новий звіт від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:
- reportType (String): Тип звіту.
- creationDate (Date): Дата створення звіту.
- text (String): Текст звіту.
- fileLink (String): Посилання на файл звіту.
- eventLogID (EventLog): Пов'язаний ідентифікатор журналу подій.

#### Відповідь 

- 200 OK:
  - Report (object): Об'єкт створеного звіту.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Report By ID

**GET** '/api/reports/{id}'

#### Опис

Отримує звіт за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор звіту.

#### Відповідь 

- 200 OK:
  - Report (object): Звіт за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що звіт не знайдено.

### Get All Reports

**GET** '/api/reports'

#### Опис

Отримує список усіх звітів.

#### Відповідь 

- 200 OK:
  - List<Report> (Array): Список усіх звітів.

### Update Report

**PUT** '/api/reports/admin/{userId}/{id}'

#### Опис

Оновлює існуючий звіт від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор звіту, який потрібно оновити.
  
Body:
- reportType (String): Тип звіту.
- creationDate (Date): Дата створення звіту.
- text (String): Текст звіту.
- fileLink (String): Посилання на файл звіту.
- eventLogID (EventLog): Пов'язаний ідентифікатор журналу подій.

#### Відповідь 

- 200 OK:
  - Report (Object): Оновлений об'єкт звіту.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що звіт не знайдено.

### Delete Report

**DELETE** '/api/reports/admin/{userId}/{id}'

#### Опис

Видаляє звіт від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор звіту, яке потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення звіту відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що звіт не знайдено.
 
# StorageConditionController API

## Маршрути

### Add Storage Condition

**POST** '/api/storage-conditions/admin/{userId}/add'

#### Опис

Додає нові умови зберігання від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:
- temperature (double): Температура зберігання.
- oxygenLevel (double): Рівень кисню.
- humidity (double): Вологість.
- measurementTime (Date): Час вимірювання.
- materialID (BiologicalMaterial): Ідентифікатор біологічного матеріалу.

#### Відповідь 

- 200 OK:
  - StorageCondition (object): Об'єкт створених умов зберігання.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Storage Condition By ID

**GET** '/api/storage-conditions/{id}'

#### Опис

Отримує умови зберігання за їх унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор умови зберігання.

#### Відповідь 

- 200 OK:
  - StorageCondition (object): Умова зберігання за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що умова зберігання не знайдена.

### Get All Storage Conditions

**GET** '/api/storage-conditions'

#### Опис

Отримує список усіх умов зберігання.

#### Відповідь 

- 200 OK:
  - List<StorageCondition> (Array): Список усіх умов зберігання.

### Update Storage Condition

**PUT** '/api/storage-conditions/admin/{userId}/{id}'

#### Опис

Оновлює існуючі умови зберігання від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор умови зберігання, яку потрібно оновити.
  
Body:
- temperature (double): Температура зберігання.
- oxygenLevel (double): Рівень кисню.
- humidity (double): Вологість.
- measurementTime (Date): Час вимірювання.
- materialID (BiologicalMaterial): Ідентифікатор біологічного матеріалу.

#### Відповідь 

- 200 OK:
  - StorageCondition (object): Оновлений об'єкт умови зберігання.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Повідомлення про те, що умова зберігання не знайдена.

### Delete Storage Condition

**DELETE** '/api/storage-conditions/admin/{userId}/{id}'

#### Опис

Видаляє умову зберігання від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор умови зберігання, яку потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення умови зберігання відбулося успішно.
- 404 Not Found:
  - message (string): Повідомлення про те, що умова зберігання не знайдена.

# UserController API

## Маршрути

### Create User

**POST** '/api/users'

#### Опис

Створює нового користувача.

#### Параметри запиту

Body:
- firstName (String): Ім'я користувача.
- lastName (String): Призвище користувача.
- role (String): Роль користувача.
- accessRights (Access): Права доступу (READ_ONLY, READ_FULL FULL).
- login (String): Логін користувача (електронна пошта).
- password (String): Пароль користувача.

#### Відповідь

- 200 OK:
  - User (object): Об'єкт створеного користувача.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.


### Create User by Admin

**POST** '/api/users/admin/{userId}/add'

#### Опис

Створює нового користувача від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

Body:
- firstName (String): Ім'я користувача.
- lastName (String): Призвище користувача.
- role (String): Роль користувача.
- accessRights (Access): Права доступу (READ_FULL, READ_ONLY, FULL).
- login (String): Логін користувача (електронна пошта).
- password (String): Пароль користувача.

#### Відповідь

- 200 OK:
  - User (object): Об'єкт створеного користувача.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Адміністратор не має прав для створення користувача.


### Get User by ID

**GET** '/api/users/{id}'

#### Опис

Отримує користувача за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор користувача.

#### Відповідь

- 200 OK:
  - User (object): Користувач за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що користувач не знайдений.

# AuthController API

## Маршрути

### Login (User Login)

**POST** '/log/in'

#### Опис

Використовуються для входу користувача до системи. Використовує логін (електронну пошту) та пароль для автентифікації.

#### Параметри запиту
Body:
- login (String): Логін користувача (email).
- password (String): Пароль користувача.

#### Відповідь 

- 200 OK:
  - message (string): Повідомлення про успішний вхід "Вхід успішний. Ваш ID: [userID]".
- 401 Unauthorized:
  - message (string): Повідомлення про невірні облікові дані.

### Logout (User Logout)

**POST** '/log/out'

#### Опис

Використовуються для виходу користувача з системи, закінчуючи сесію.

#### Параметри запиту
Query:
- userId (Long): Ідентифікатор користувача, який виходить.

#### Відповідь 

- 200 OK:
  - message (string): Повідомлення про успішний вихід "Вихід успішний".
 
# Моделів даних

## BiologicalMaterial
Модель для біологічного матеріалу.

- `materialID` - Унікальний ідентифікатор біологічного матеріалу
- `materialName` - Назва біологічного матеріалу (від 2 до 100 символів)
- `expirationDate` - Дата закінчення терміну придатності біологічного матеріалу (має бути у майбутньому)
- `status` - Статус пожертвування (потрібно вказати статус пожертвування: `AVAILABLE`, `COLLECTED`, `DONATED`, `PENDING` `DISPOSED` )
- `transferDate` - Дата передачі матеріалу (має бути в минулому або поточному часі)
- `donorID` - Ідентифікатор донора, що надав біологічний матеріал (не може бути порожнім)

## Donor
Модель для донора біологічного матеріалу.

- `donorID` - Унікальний ідентифікатор донора
- `firstName` - Ім'я донора (від 2 до 100 символів)
- `lastName` - Прізвище донора (від 2 до 100 символів)
- `birthDate` - Дата народження донора (має бути в минулому)
- `gender` - Стать донора (`MALE`, `FEMALE`)
- `idNumber` - Ідентифікаційний номер донора (10 символів, алфавітно-цифровий формат)
- `bloodType` - Група крові донора (наприклад, `A_POS`, `O_NEG`)
- `transplantRestrictions` - Обмеження на трансплантацію (не більше 500 символів)

## EventLog
Модель для запису дій користувача в системі.

- `eventLogID` - Унікальний ідентифікатор запису події
- `actionDetails` - Опис дії користувача (від 2 до 1000 символів)
- `actionTime` - Час виконання дії (має бути в минулому або поточному часі)
- `creatorID` - Ідентифікатор користувача, що виконав дію (може бути порожнім)

## Notification
Модель для сповіщення про події в системі.
- `notificationID` - Унікальний ідентифікатор сповіщення
- `eventTime` - Час події (має бути в минулому або поточному часі)
- `eventType` - Тип події (від 2 до 100 символів)
- `details` - Опис події (від 5 до 500 символів)
- `status` - Статус сповіщення (від 2 до 50 символів)
- `materialID` - Ідентифікатор біологічного матеріалу, пов'язаного з подією (не може бути порожнім)

## Report
Модель для звіту в системі.
- `reportID` - Унікальний ідентифікатор звіту
- `reportType` - Тип звіту (від 2 до 100 символів)
- `creationDate` - Дата створення звіту (має бути в минулому або поточному часі)
- `text` - Текст звіту (від 5 до 1000 символів)
- `fileLink` - Посилання на файл звіту (від 5 до 500 символів)
- `eventLogID` - Ідентифікатор запису події, до якої прив'язаний звіт (не може бути порожнім)

## StorageCondition
Модель для умов зберігання біологічного матеріалу.
- `recordID` - Унікальний ідентифікатор запису умов зберігання
- `temperature` - Температура (від -100 до 100 градусів, не може бути порожнім)
- `oxygenLevel` - Рівень кисню (від 0 до 100%, не може бути порожнім)
- `humidity` - Вологість (від 0 до 100%, не може бути порожнім)
- `measurementTime` - Час вимірювання (має бути в минулому або поточному часі)
- `materialID` - Ідентифікатор біологічного матеріалу, до якого відносяться умови зберігання (не може бути порожнім)

## User
Модель для користувача системи.
- `userID` - Унікальний ідентифікатор користувача
- `firstName` - Ім'я користувача (від 2 до 255 символів)
- `lastName` - Призвище користувача (від 2 до 255 символів)
- `role` - Роль користувача (від 2 до 255 символів)
- `accessRights` - Права доступу користувача (можливі значення: `FULL`, `READ_ALL`, `READ_ONLY`)
- `login` - Логін користувача (електронна пошта, від 2 до 100 символів)
- `password` - Пароль користувача (не менше 6 символів)
