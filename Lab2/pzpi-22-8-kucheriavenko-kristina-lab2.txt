Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії
 






Лабораторна робота
з дисципліни: «Архітектура програмного забезпечення»
на тему: Розробка програмної архітектури, створення та відлагодження програмного коду серверної частини програмної системи»
 



									Виконала: 	
									ст. гр. ПЗПІ-22-8	
									Кучерявенко К. Р.
									3 травня 2025 р.
									Перевірив:						 						Ст. викл. Сокорчук І. П.

                                                					



Харків 2025
2 РОЗРОБКА ПРОГРАМНОЇ АРХІТЕКТУРИ, СТВОРЕННЯ ТА
ВІДЛАГОДЖЕННЯ ПРОГРАМНОГО КОДУ СЕРВЕРНОЇ ЧАСТИНИ
ПРОГРАМНОЇ СИСТЕМИ
2.1. Історія змін


Зміни в документі нотуються до таблиці 2.1.

Таблиця 2.1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	03.05.25	0.1	Створено розділ «Історія змін»
2	03.05.25	0.1	Створено розділ «Завдання»
3	03.05.25	0.1	Створено розділ «Опис виконаної роботи»
4	03.05.25	0.1	Створено розділ «Висновки»
5	10.05.25	0.1	Додано додаток А з посиланням на відеоролик
6	10.05.25	0.1	Додано додаток Б з графічними матеріалами
7	10.05.25	0.1	Додано додаток В з програмним кодом
8	10.05.25	0.1	Додано додаток Г з специфікацію REST


2.2 Завдання


	Мета завдання – розробити серверну (back-end) частину програмної системи, що забезпечує повноцінне управління даними користувачів, реалізацію бізнес-логіки, взаємодію з базою даних та зовнішніми сервісами, а також підтримує масштабування та безпеку. У рамках завдання необхідно спроєктувати архітектуру серверної частини, реалізувати REST API, обрати відповідні програмні технології, провести функціональне тестування та описати прийняті інженерні рішення.

2.3 Опис виконаної роботи


Програмна система є серверною частиною інформаційної системи управління біологічними матеріалами. Вона розроблена для забезпечення зберігання, обліку, обробки та контролю за біологічними матеріалами та пов’язаними з ними даними. Система підтримує три рівні доступу користувачів: звичайний, частковий та повний, кожен з яких має власний набір дозволених дій відповідно до ролі.
Архітектура програмної системи реалізована відповідно до принципів багаторівневої архітектури (three-tier architecture), з чітким розділенням на:
–	контролери (Controller): приймають HTTP-запити, викликають відповідні сервіси та повертають відповіді клієнту;
–	сервіси (Service): реалізують бізнес-логіку та взаємодіють із репозиторіями;
–	репозиторії (Repository): відповідають за доступ до бази даних (PostgreSQL), використовуючи ORM (Spring Data JPA).
Архітектурний стиль взаємодії між компонентами реалізований за допомогою REST API, що дозволяє зручно та стандартизовано обмінюватися даними з іншими системами або майбутніми клієнтськими застосунками (веб та мобільним інтерфейсом).
Серверна частина побудована з використанням мови Java та фреймворку Spring Boot, що забезпечує гнучкість, модульність та високу швидкість розробки. Основними модулями системи є:
–	модуль управління біоматеріалами: облік, реєстрація, редагування, видалення біоматеріалів;
–	модуль донорів: зберігання та обробка інформації про донорів;
–	модуль логування: фіксація дій користувачів і подій у системі;
–	модуль сповіщень: надсилання системних повідомлень користувачам;

–	модуль звітів: формування та збереження звітів за вибраними параметрами;
–	модуль умов зберігання: визначення температурного режиму, вологості, строків тощо;
–	модуль користувачів: реєстрація, авторизація, призначення ролей та керування доступом.
Завдяки гнучкості архітектури та модульному підходу система легко масштабується, підтримує розширення функціональності, а також спрощує супровід і тестування. Кожен з модулів є ізольованим з погляду логіки, але може взаємодіяти з іншими через сервісний рівень.
	Математичні методи обробки даних використовуються під час аналізу умов зберігання матеріалів. При отриманні даних про температуру, вологість та кисень, система розраховує показники, що характеризують відповідність цих значень до ідеальних умов зберігання. Для цього визначаються нормалізовані відхилення для кожного з параметрів на основі ідеальних значень. Нормалізація здійснюється за допомогою формул нормалізації температури (1), нормалізації вологості (2), нормалізації рівня кисню (3). Формула для температури:
normHumidity=1-((humidity-idealHumidity)/10)				(1)
де humidity – фактична температура матеріалу, яка вимірюється в процесі зберігання, 
	idealHumidity – ідеальна температура зберігання матеріалу, задана для кожного матеріалу окремо.
Формула визначає відхилення фактичного рівня вологості від ідеального. Якщо вологість матеріалу збігається з ідеальною, значення T_n буде 1.0. Відхилення більше, ніж на 100% від ідеалу, знижує значення. Формула для вологості:
normOxygen=1-((oxygenLevel-idealOxygenLeve)/100)				(1)
де oxygenLevel – фактичний рівень кисню в оточенні матеріалу, 
	idealOxygenLevel – ідеальний рівень кисню для зберігання матеріалу.
Аналогічно попередній формулі, ця формула визначає відхилення фактичного рівня кисню від ідеального, нормалізуючи його до значення в межах 0 – 1. Значення normOxygen буде максимальним, якщо рівень кисню відповідає ідеальному. Формула для рівня кисню:
normOxygen=1-((oxygenLevel-idealOxygenLevel)/100)				(1)
де oxygenLevel – фактичний рівень кисню в оточенні матеріалу, 
	idealOxygenLevel – ідеальний рівень кисню для зберігання матеріалу.
Аналогічно попереднім формулам, ця формула визначає відхилення фактичного рівня кисню від ідеального, нормалізуючи його до значення в межах 0 – 1. Значення normOxygen буде максимальним, якщо рівень кисню відповідає ідеальному.
Для отримання загальний стан умов зберігання матеріалу, враховуючи всі три параметри: температуру, вологість і рівень кисню, використовується формула загального балу (4). Кожному з параметрів присвоєна вага: 50% для температури, 30% для вологості і 20% для рівня кисню. Це дає змогу більше впливати на загальний результат параметрам, що є критичнішими для зберігання. Результат може бути в діапазоні від 0 (незадовільні умови зберігання) до 1 (ідеальні умови зберігання). Формула:
environmentScore=(normTemp×0.5+normHumidity×0.3+normOxygen×0.2)	(4)
де normTemp, normHumidity, normOxygen – розраховуються з вищезгаданих формул.
Ці формули дозволяють контролювати стан матеріалу в реальному часі, виявляючи відхилення від ідеальних умов зберігання, і вчасно коригувати параметри зберігання.
База даних проєкту реалізована у системі керування базами даних PostgreSQL та побудована відповідно до предметної області управління біологічними матеріалами. Вона включає сім основних таблиць, які відповідають основним модулям системи. Для кожної таблиці чітко визначено атрибути, типи даних, зв’язки з іншими таблицями, а також умови заповнення полів та обмеження цілісності даних. Нижче подано опис основних таблиць та їхніх полів.
Таблиця BiologicalMaterials:
–	materialID унікальний ідентифікатор запису, генерується автоматично;
–	materialName обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	expirationDate обов’язкове поле, дата має бути у майбутньому;
–	status обов’язкове поле, перелічуваний тип даних, значення, окрім визначених у переліку, не дозволяються;
–	transferDate обов’язкове поле, дата, яка має бути у минулому або сьогоденні;
–	donorID обов’язкове поле, зв’язок з таблицею Donors, не може бути пустим;
–	idealTemperature обов’язкове поле, числове значення у межах від -100 до 100;
–	 idealOxygenLevel обов’язкове поле, числове значення у межах від 0 до 100;
–	idealHumidity обов’язкове поле, числове значення у межах від 0 до 100.
Таблиця Donors:
–	donorID унікальний ідентифікатор донора, генерується автоматично;
–	firstName обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	lastName обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	birthDate обов’язкове поле, дата, яка має бути у минулому;
–	gender обов’язкове поле, перелічуваний тип даних, значення, окрім визначених у переліку, не дозволяються;
–	idNumber обов’язкове поле, унікальний ідентифікатор донора, що відповідає шаблону з 10 латинських літер та цифр;
–	bloodType обов’язкове поле, перелічуваний тип даних для групи крові;
–	transplantRestrictions необов’язкове поле, рядок до 500 символів, може залишатися пустим.
Таблиця EventLogs:
–	eventLogID унікальний ідентифікатор запису, генерується автоматично;
–	actionDetails обов’язкове поле, рядок довжиною від 2 до 1000 символів, не може бути пустим;
–	actionTime обов’язкове поле, дата має бути у минулому або сьогоденні;
–	creatorID обов’язкове поле, зв’язок з таблицею Users, не може бути пустим.
Таблиця Notifications:
–	notificationID унікальний ідентифікатор запису, генерується автоматично;
–	eventType обов’язкове поле, рядок довжиною від 2 до 100 символів, не може бути пустим;
–	details обов’язкове поле, рядок довжиною від 5 до 500 символів, не може бути пустим;
–	materialID обов’язкове поле, зв’язок з таблицею BiologicalMaterials, не може бути пустим.
Таблиця StorageCondition:
–	recordID унікальний ідентифікатор запису, генерується автоматично;
–	temperature обов’язкове поле, числове значення у межах від -100 до 100;
–	oxygenLevel обов’язкове поле, числове значення у межах від 0 до 100;
–	humidity обов’язкове поле, числове значення у межах від 0 до 100;
–	measurementTime обов’язкове поле,  дата має бути у минулому або сьогоденні;
–	zone перелічуваний тип даних, не може бути пустим;
–	materialID обов’язкове поле, зв’язок з таблицею BiologicalMaterials, не може бути пустим.
Таблиця Users:
–	userID унікальний ідентифікатор запису, генерується автоматично;
–	firstName обов’язкове поле, рядок довжиною від 2 до 255 символів, не може бути пустим;
–	lastName обов’язкове поле, рядок довжиною від 2 до 255 символів, не може бути пустим;
–	role обов’язкове поле, рядок довжиною від 2 до 255 символів, не може бути пустим;
–	accessRights поле містить значення за умовчанням, перелічуваний тип даних, не може бути пустим;
–	login обов’язкове поле, унікальний рядок довжиною від 2 до 100 символів, форматоване як email;
–	password обов’язкове поле, рядок довжиною не менше 6 символів, не може бути пустим.
Специфікація REST знаходиться у додатку Г.
У розробці серверної частини програмної системи управління біологічними матеріалами використано сучасні, надійні та масштабовані технології, що забезпечують чітку архітектуру, безпеку та зручність супроводу проєкту. Мова програмування Java 22, обрана за свою стабільність, підтримку великої спільноти та сумісність із Spring Framework. Фреймворк: Spring Boot, дозволяє швидко створювати готові до продакшну REST-сервіси з вбудованим веб-сервером та автоматизованою конфігурацією. Архітектура: MVC (Model–View–Controller). Серверна частина реалізована за принципом Controller → Service → Repository, що забезпечує модульність та розділення обов’язків. ORM: Spring Data JPA (на базі Hibernate) Дозволяє взаємодіяти з базою даних PostgreSQL через об’єктно-реляційне відображення. База даних: PostgreSQL, потужна, відкрита реляційна СУБД з широкими можливостями, що добре підходить для зберігання структурованих медичних і користувацьких даних. Валідація: Jakarta Bean Validation (раніше Hibernate Validator). Застосовується для перевірки вхідних даних у моделях (наприклад, @NotNull, @Size, @Email, @Pattern тощо). Усі запити обробляються через REST-контролери (@RestController), які обслуговують клієнтів JSON-відповідями.
На поточному етапі реалізації система не підтримує інтерналізацію (I18N), тобто зміна мови відповіді для різних локалей не реалізована.
Нижче наведені основні компоненти реалізації.
Контролери (@RestController) – реалізують обробку HTTP-запитів від клієнтської частини. Для кожної сутності (наприклад, BiologicalMaterialsController, DonorsController) створено окремий REST-контролер з методами CRUD (GET, POST, PUT, DELETE).
Сервіси (@Service) – містять бізнес-логіку. У сервісах реалізується перевірка умов (наприклад, чи існує донор, чи дата дійсна), виклики репозиторіїв і обробка результатів.
Репозиторії (@Repository, інтерфейси, що наслідують JpaRepository) – відповідають за взаємодію з базою даних. Для кожної сутності створено окремий репозиторій.
Сутності (@Entity) – кожна таблиця в базі даних має відповідну модель у вигляді Java-класу з анотаціями (@Column, @NotNull, @Pattern, @Enumerated тощо), які описують правила зберігання та валідації даних.
Валідація даних – за допомогою jakarta.validation (@Valid, @NotBlank, @Size, @Past, @Future, @Pattern) забезпечується перевірка вхідних даних до обробки логіки.
Функціональне тестування проводилося з використанням Postman –популярного інструменту для роботи з API-запитами. Основні етапи тестування включали запуск локального сервера Spring Boot (localhost:8080), імпорт колекції запитів Postman для кожного з ресурсів (/donors, /materials, /reports, тощо), перевірка коректності CRUD-операцій, тестування валідації, тестування зв’язків між таблицями та унікальності. У додатку Б розташовані графічні матеріали, а саме:  UML діаграма розгортання (Deployment Diagram), UML діаграма прецедентів (Use Case Diagram), ER-модель даних (Entity–Relationship Model), UML діаграма взаємодії (Interaction Overview Diagram). Приклад фрагментів коду знаходиться у додатку В. Специфікація REST розташована у додатку Г.


2.4 Висновки 


	У ході виконаної роботи було успішно реалізовано серверну частину інформаційної системи управління біологічними матеріалами, яка базується на багаторівневій архітектурі з чітким розподілом відповідальностей між компонентами. Система забезпечує надійне зберігання, обробку та контроль біоматеріалів, а також підтримує диференційований доступ для користувачів з різними ролями. Завдяки використанню фреймворку Spring Boot, ORM Spring Data JPA та бази даних PostgreSQL досягнуто високої продуктивності, гнучкості й масштабованості. Особливу увагу приділено модульності системи, логуванню дій, аналітиці умов зберігання за допомогою математичних методів та стандартизованому REST API для інтеграції з іншими сервісами. Таким чином, створена програмна система є надійною платформою для подальшого розвитку, інтеграції та розширення функціональних можливостей. 
Додаток А
	Хронологічний опис та посилання

Відеозапис доповіді на YouTube: https://youtu.be/ibaqjx_JtD8

Хронологічний опис доповіді:
00:00 Вступна частина
Короткий вступ, у якому пояснюється, про що буде ролик.
00:20 Тестування: біоматеріали
Показано тестування API для біоматеріалів:
–	створення через POST-запит із перевіркою ролі користувача;
–	отримання одного матеріалу по ID через GET-запит;
–	отримання всіх матеріалів через GET-запит;
–	оновлення з перевіркою коректності даних через PUT-запит;
–	видалення через DELETE-запит із перевіркою ролі користувача.
00:59 Тестування: донори
Показано тестування API для донорів:
–	створення через POST-запит із перевіркою ролі користувача;
–	отримання одного донора по ID через GET-запит;
–	отримання всіх донорів через GET-запит;
–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
–	видалення через DELETE-запит із перевіркою ролі користувача.
01:45 Тестування: логування
Показано тестування API для логування:
–	створення через POST-запит із валідацією користувача із перевіркою ролі користувача, доступ лише за ролі FULL;
–	отримання один запис логування по ID через GET-запит із перевіркою ролі користувача;
–	отримання всі записи логування через GET-запит із перевіркою ролі користувача;
–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
–	видалення через DELETE-запит із перевіркою ролі користувача.
02:35 Тестування: сповіщення
Показано тестування API для сповіщень:
–	створення через POST-запит із валідацією користувача із перевіркою ролі користувача;
–	отримання одного запису сповіщення по ID через GET-запит;
–	отримання всіх записів сповіщень через GET-запит;
–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
–	видалення через DELETE-запит із перевіркою ролі користувача.
03:15 Тестування: умови зберігання
Показано тестування API для умов зберігання:
–	створення через POST-запит із валідацією користувача із перевіркою ролі користувача;
–	отримання одного запису умов зберігання по ID через GET-запит;
–	отримання всіх записів умов зберігання через GET-запит;
–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;
–	видалення через DELETE-запит із перевіркою ролі користувача.
04:13 Тестування: користувачі
Показано тестування API для користувачів:
–	створення через POST-запит звичайного користувача;
–	створення через POST-запит користувача з певними правами доступу;
–	отримання одного користувача по ID через GET-запит;
–	отримання всіх користувачів через GET-запит;
–	оновлення з перевіркою коректності даних через PUT-запит із перевіркою ролі користувача;;
–	видалення через DELETE-запит із перевіркою ролі користувача.
05:28 Тестування: автоматичне створення бекапу за розкладом
Перегляд папки «db» та відсутність в ній файлі. Відбувається запуск серверу. Продемонстровано автоматичне створення бекапу за розкладом «кожні 10 сек». В консолі виводиться текст про успішність (або помилку). Демонстрація папки «db» з щойно створеними бекапами бази даних. 
06:07 Тестування: демонстрація математичних методи обробки даних
Коротке пояснення як працює математична обробка даних, на що воно впливає. Відбувається створення нового запису для тестування, після чого відбувалось тестування розрахунку та результатів. Інформація про зони та що вони значать, при порушенні надсилається повідомлення, які було продемонстровано на екрані.
 
Додаток Б
Графічні матеріали


 
Рисунок Б.1 – ER-діаграма даних

 
Рисунок Б.2 – Структура бази даних

 
Рисунок Б.3 – UML-діаграма прецедентів

 
Рисунок Б.4 – UML діаграма розгортання

 
Додаток В
Програмний код

В.1 Математична обробка прикладних даних
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/service/StorageConditionService.java
1. public double calculateEnvironmentScore(StorageCondition condition) {
 2.     BiologicalMaterial material = biologicalMaterialService.getBiologicalMaterialById(condition.getMaterialID().getMaterialID());
 3. 
 4.     double idealTemp = material.getIdealTemperature();
 5.     double idealHumidity = material.getIdealHumidity();
 6.     double idealOxygen = material.getIdealOxygenLevel();
 7. 
 8.     double normTemp = 1 - Math.abs((condition.getTemperature() - idealTemp) / 10.0);
 9.     double normHumidity = 1 - Math.abs((condition.getHumidity() - idealHumidity) / 100.0);
10.     double normOxygen = 1 - Math.abs((condition.getOxygenLevel() - idealOxygen) / 100.0);
11. 
12.     return (normTemp * 0.5 + normHumidity * 0.3 + normOxygen * 0.2);
13. }
14. 
15. public StorageZone determineZone(double score) {
16.     if (score < 0.3) return StorageZone.RED;
17.     if (score < 0.7) return StorageZone.YELLOW;
18.     return StorageZone.GREEN;
19. }

В.2 Резервне копіювання користувацьких даних
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/config/BackupService.java
1. @Service
2. public class BackupService {
3. 
4.     @Value("${backup.path}")
5.     private String backupPath;
6.     @Value("${spring.datasource.password}")
7.     private String password;
8. 
9.     @Scheduled(cron = "0 0 4 * * *")//кожен день о 04:00
10.     public void performBackup() {
11.         if (backupPath == null) {
12.             System.err.println("Path is null");
13.             return;
14.         }
15. 
16.         File backupDir = new File(backupPath);
17.         if (!backupDir.exists()) {
18.             boolean created = backupDir.mkdirs();
19.             if (!created) {
20.                 System.err.println("Failed to create backup directory");
21.                 return;
22.             }
23.         }
24. 
25.         String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
26.         String fileName = "backup_" + timestamp + ".sql";
27.         File backupFile = new File(backupDir, fileName);
28. 
29.         try {
30.             ProcessBuilder pb = new ProcessBuilder(
31.                     "C:\\Program Files\\PostgreSQL\\17\\bin\\pg_dump.exe",
32.                     "-U", "postgres",
33.                     "-F", "c",
34.                     "-f", backupFile.getAbsolutePath(),
35.                     "system-for-managing-medical-biological-materials"
36.             );
37. 
38.             pb.environment().put("PGPASSWORD", password);
39. 
40.             Process process = pb.start();
41.             int exitCode = process.waitFor();
42. 
43.             BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
44.             String line;
45.             while ((line = reader.readLine()) != null) {
46.                 System.err.println(line);
47.             }
48. 
49.             if (exitCode == 0) {
50.                 System.out.println("Backup successfully created");
51.             } else {
52.                 System.err.println("Error creating backup. Code: " + exitCode);
53.             }
54. 
55.         } catch (Exception e) {
56.             e.printStackTrace();
57.         }
58.     }
59. }

В.3 Адміністрування бізнес-логіки системи
GitHub репозиторій: https://github.com/NureKucheriavenkoKristina/apz-pzpi-22-8-kucheriavenko-kristina/blob/main/Lab2/pzpi-22-8-kucheriavenko-kristina-lab2/controllers/BiologicalMaterialController.java
1. package com.BiologicalMaterialsSystem.controllers;
2.
3. import java.util.List;
4. import com.BiologicalMaterialsSystem.model.*;
5. import com.BiologicalMaterialsSystem.service.*;
6. import jakarta.validation.Valid;
7. import lombok.RequiredArgsConstructor;
8. import org.springframework.http.HttpStatus;
9. import org.springframework.http.ResponseEntity;
10. import org.springframework.validation.BindingResult;
11. import org.springframework.web.bind.annotation.*;
12.
13. @RequiredArgsConstructor
14. @RestController
15. @RequestMapping("/api/biological-materials")
16. @CrossOrigin(origins = "*")
17. public class BiologicalMaterialController {
18.
19.     private final BiologicalMaterialService biologicalMaterialService;
20.     private final UserService userService;
21.
22.     @PostMapping("/{userId}/add")
23.     public ResponseEntity<BiologicalMaterial> createBiologicalMaterial(
24.             @PathVariable("userId") Long userId,
25.             @Valid @RequestBody BiologicalMaterial biologicalMaterial,
26.             BindingResult result) {
27.
28.         if (result.hasErrors()) {
29.             return ResponseEntity.badRequest().body(null);
30.         }
31.
32.         User user = userService.getUserById(userId);
33.         if (user == null) {
34.             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
35.         }
36.
37.         biologicalMaterialService.createBiologicalMaterial(user, biologicalMaterial);
38.         return ResponseEntity.ok(biologicalMaterial);
39.     }
40.
41.     @GetMapping("/{materialID}")
42.     public ResponseEntity<BiologicalMaterial> getBiologicalMaterialById(@PathVariable("materialID") Long materialID) {
43.         BiologicalMaterial material = biologicalMaterialService.getBiologicalMaterialById(materialID);
44.         if (material == null) {
45.             return ResponseEntity.notFound().build();
46.         }
47.         return ResponseEntity.ok(material);
48.     }
49.
50.     @GetMapping
51.     public ResponseEntity<List<BiologicalMaterial>> getAllBiologicalMaterials() {
52.         List<BiologicalMaterial> materials = biologicalMaterialService.getAllBiologicalMaterials();
53.         return ResponseEntity.ok(materials);
54.     }
55.
56.     @PutMapping("/{userId}/{materialID}")
57.     public ResponseEntity<BiologicalMaterial> updateBiologicalMaterial(
58.             @PathVariable("userId") Long userId,
59.             @PathVariable("materialID") Long materialID,
60.             @Valid @RequestBody BiologicalMaterial biologicalMaterial,
61.             BindingResult result) {
62.
63.         if (result.hasErrors()) {
64.             return ResponseEntity.badRequest().body(null);
65.         }
66.
67.         User user = userService.getUserById(userId);
68.         if (user == null) {
69.             return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
70.         }
71.
72.         BiologicalMaterial updatedMaterial = biologicalMaterialService.updateBiologicalMaterial(user, materialID, biologicalMaterial);
73.         return ResponseEntity.ok(updatedMaterial);
74.     }
75.
76.     @DeleteMapping("/admin/{userId}/{materialID}")
77.     public ResponseEntity<Void> deleteBiologicalMaterial(
78.             @PathVariable("userId") Long userId,
79.             @PathVariable("materialID") Long materialID) {
80.
81.         User user = userService.getUserById(userId);
82.         if (user == null) {
83.             return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
84.         }
85.
86.         biologicalMaterialService.deleteBiologicalMaterial(user, materialID);
87.         return ResponseEntity.noContent().build();
88.     }
89. } 
Додаток Г
Специфікація REST


# API Документація для проєкту "Програмна система для управлінням медичними біологічними матеріалами"

API забезпечує функціональність для управління медичними біологічними матеріалами. Він дозволяє реєструвати, відстежувати та аналізувати матеріали, забезпечуючи інтеграцію з IoT пристроями для моніторингу умов зберігання.

## Контролери 

# BiologicalMaterialController API

## Маршрути

### Add Biological Material

**POST** '/api/biological-materials/admin/{userId}/add'

#### Опис

Додає новий біологічний матеріал від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

Body:
- materialName (String): Назва біологічного матеріалу.
- expirationDate (Date): Дата закінчення терміну придатності.
- status (DonationStatus): Статус донорства.
- transferDate (Date): Дата передачі матеріалу.
- idealTemperature (double): Ідеальна температура зберігання.
- idealOxygenLevel (double): Ідеальний рівень кисню.
- idealHumidity (double): Ідеальна вологість.
- donorID (Long): Ідентифікатор донора.

#### Відповідь 

- 200 OK:
  - BiologicalMaterial (object): Об'єкт створеного матеріалу.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Biological Material By ID

**GET** '/api/biological-materials/{materialID}'

#### Опис

Отримує біологічний матеріал за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- materialID (Long): Ідентифікатор матеріалу.

#### Відповідь 

- 200 OK:
  - BiologicalMaterial (object): Біологічний матеріал за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що матеріал не знайдено.

### Get All Biological Materials

**GET** '/api/biological-materials'

#### Опис

Отримує всі біологічні матеріали.

#### Відповідь 

- 200 OK:
  - List<BiologicalMaterial> (Array): Список усіх біологічних матеріалів.


### Update Biological Material

**PUT** '/api/biological-materials/admin/{userId}/{materialID}'

#### Опис

Оновлює існуючий біологічний матеріал від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- materialID (Long): Ідентифікатор матеріалу, який потрібно оновити.
  
Body:
- materialName (String): Назва біологічного матеріалу.
- expirationDate (Date): Дата закінчення терміну придатності.
- status (DonationStatus): Статус донорства.
- transferDate (Date): Дата передачі матеріалу.
- idealTemperature (double): Ідеальна температура зберігання.
- idealOxygenLevel (double): Ідеальний рівень кисню.
- idealHumidity (double): Ідеальна вологість.
- donorID (Long): Ідентифікатор донора.

#### Відповідь 

- 200 OK:
  - BiologicalMaterial (Object): Оновлений біологічний матеріал.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що матеріал не знайдено.

### Delete Biological Material

**DELETE** '/api/biological-materials/admin/{userId}/{materialID}'

#### Опис

Видаляє біологічний матеріал від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- materialID (Long): Ідентифікатор матеріалу, який потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення матеріалу відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що матеріал не знайдено.

# DonorController API

## Маршрути

### Add Donor

**POST** '/api/donors/admin/{userId}/add'

#### Опис

Додає нового донора від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

Body:
- firstName (String): Ім'я донора.
- lastName (String): Прізвище донора.
- birthDate (Date): Дата народження донора.
- gender (Gender): Стать донора.
- idNumber (String): Ідентифікаційний номер донора.
- bloodType (RhFactorOfBlood): Група крові донора.
- transplantRestrictions (String): Обмеження на трансплантацію.

#### Відповідь 

- 200 OK:
  - Donor (object): Об'єкт створеного донора.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Donor By ID

**GET** '/api/donors/{DonorID}'

#### Опис

Отримує інформацію про донора за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- DonorID (Long): Ідентифікатор донора.

#### Відповідь 

- 200 OK:
  - Donor (object): Донор за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що донор не знайдений.

### Get All Donors

**GET** '/api/donors'

#### Опис

Отримує список усіх донорів.

#### Відповідь 

- 200 OK:
  - List<Donor> (Array): Список усіх донорів.

### Update Donor

**PUT** '/api/donors/admin/{userId}/{DonorID}'

#### Опис

Оновлює існуючого донора від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- DonorID (Long): Ідентифікатор донора, якого потрібно оновити.
  
Body:
- firstName (String): Ім'я донора.
- lastName (String): Прізвище донора.
- birthDate (Date): Дата народження донора.
- gender (Gender): Стать донора.
- idNumber (String): Ідентифікаційний номер донора.
- bloodType (RhFactorOfBlood): Група крові донора.
- transplantRestrictions (String): Обмеження на трансплантацію.

#### Відповідь 

- 200 OK:
  - Donor (Object): Оновлений об'єкт донора.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що донор не знайдений.

### Delete Donor

**DELETE** '/api/donors/admin/{userId}/{id}'

#### Опис

Видаляє донора від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор донора, якого потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення донора відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що донор не знайдений.

# EventLogController API

## Маршрути

### Add Event Log

**POST** '/api/event-logs/admin/{userId}/add'

#### Опис

Додає новий запис про подію від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:
- actionDetails (String): Деталі дії.
- actionTime (Date): Час виконання дії.

#### Відповідь 

- 200 OK:
  - EventLog (object): Об'єкт створеного запису про подію.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Event Log By ID

**GET** '/api/event-logs/admin/{userId}/{id}'

#### Опис

Отримує запис про подію за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор запису.

#### Відповідь 

- 200 OK:
  - EventLog (object): Запис про подію за вказаним ідентифікатором.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Запис не знайдено.

### Get All Event Logs

**GET** '/api/event-logs/admin/{userId}'

#### Опис

Отримує всі записи про події.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

#### Відповідь 

- 200 OK:
  - List<EventLog> (Array): Список всіх записів про події.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.

### Update Event Log

**PUT** '/api/event-logs/admin/{userId}/{id}'

#### Опис

Оновлює існуючий запис про подію від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор запису, який потрібно оновити.
  
Body:
- actionDetails (String): Деталі дії.
- actionTime (Date): Час виконання дії.

#### Відповідь 

- 200 OK:
  - EventLog (Object): Оновлений запис про подію.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Запис не знайдено.

### Delete Event Log

**DELETE** '/api/event-logs/admin/{userId}/{id}'

#### Опис

Видаляє запис про подію від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор запису, який потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення запису про подію відбулося успішно.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Запис не знайдено.
 
# NotificationController API

## Маршрути

### Add Notification

**POST** '/api/notifications/admin/{userId}/add'

#### Опис

Додає нове сповіщення від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:
- eventType (String): Тип події.
- details (String): Деталі сповіщення.
- materialID (BiologicalMaterial): Біологічний матеріал, що пов'язаний зі сповіщенням.

#### Відповідь 

- 200 OK:
  - Notification (object): Об'єкт створеного сповіщення.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Notification By ID

**GET** '/api/notifications/{id}'

#### Опис

Отримує сповіщення за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор сповіщення.

#### Відповідь 

- 200 OK:
  - Notification (object): Сповіщення за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що сповіщення не знайдено.

### Get All Notifications

**GET** '/api/notifications'

#### Опис

Отримує список усіх сповіщень.

#### Відповідь 

- 200 OK:
  - List<Notification> (Array): Список усіх сповіщень.

### Update Notification

**PUT** '/api/notifications/admin/{userId}/{id}'

#### Опис

Оновлює існуюче сповіщення від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор сповіщення, яке потрібно оновити.
  
Body:
- eventType (String): Тип події.
- details (String): Деталі сповіщення.
- materialID (BiologicalMaterial): Біологічний матеріал, що пов'язаний зі сповіщенням.

#### Відповідь 

- 200 OK:
  - Notification (Object): Оновлений об'єкт сповіщення.
- 400 Bad Request:
  - message (String): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (String): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (String): Повідомлення про те, що сповіщення не знайдено.

### Delete Notification

**DELETE** '/api/notifications/admin/{userId}/{id}'

#### Опис

Видаляє сповіщення від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор сповіщення, яке потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення сповіщення відбулося успішно.
- 404 Not Found:
  - message (String): Повідомлення про те, що сповіщення не знайдено.

# StorageConditionController API

## Маршрути

### Add Storage Condition

**POST** '/api/storage-conditions/admin/{userId}/add'

#### Опис

Додає нові умови зберігання від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
  
Body:
- temperature (double): Температура зберігання.
- oxygenLevel (double): Рівень кисню.
- humidity (double): Вологість.
- measurementTime (Date): Час вимірювання.
- zone (StorageZone): Зона зберігання.
- materialID (BiologicalMaterial): Ідентифікатор біологічного матеріалу.

#### Відповідь 

- 200 OK:
  - StorageCondition (object): Об'єкт створених умов зберігання.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Адміністратора не знайдено.

### Get Storage Condition By ID

**GET** '/api/storage-conditions/{id}'

#### Опис

Отримує умови зберігання за їх унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор умови зберігання.

#### Відповідь 

- 200 OK:
  - StorageCondition (object): Умова зберігання за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що умова зберігання не знайдена.

### Get All Storage Conditions

**GET** '/api/storage-conditions'

#### Опис

Отримує список усіх умов зберігання.

#### Відповідь 

- 200 OK:
  - List<StorageCondition> (Array): Список усіх умов зберігання.

### Update Storage Condition

**PUT** '/api/storage-conditions/admin/{userId}/{id}'

#### Опис

Оновлює існуючі умови зберігання від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор умови зберігання, яку потрібно оновити.
  
Body:
- temperature (double): Температура зберігання.
- oxygenLevel (double): Рівень кисню.
- humidity (double): Вологість.
- measurementTime (Date): Час вимірювання.
- zone (StorageZone): Зона зберігання.
- materialID (BiologicalMaterial): Ідентифікатор біологічного матеріалу.

#### Відповідь 

- 200 OK:
  - StorageCondition (object): Оновлений об'єкт умови зберігання.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Відсутність дозволу на виконання дії.
- 404 Not Found:
  - message (string): Повідомлення про те, що умова зберігання не знайдена.

### Delete Storage Condition

**DELETE** '/api/storage-conditions/admin/{userId}/{id}'

#### Опис

Видаляє умову зберігання від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.
- id (Long): Ідентифікатор умови зберігання, яку потрібно видалити.

#### Відповідь 

- 204 No Content:
  - Видалення умови зберігання відбулося успішно.
- 404 Not Found:
  - message (string): Повідомлення про те, що умова зберігання не знайдена.

# UserController API

## Маршрути

### Create User

**POST** '/api/users'

#### Опис

Створює нового користувача.

#### Параметри запиту

Body:
- firstName (String): Ім'я користувача.
- lastName (String): Призвище користувача.
- role (String): Роль користувача.
- accessRights (Access): Права доступу (READ_ONLY, READ_FULL FULL).
- login (String): Логін користувача (електронна пошта).
- password (String): Пароль користувача.

#### Відповідь

- 200 OK:
  - User (object): Об'єкт створеного користувача.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.


### Create User by Admin

**POST** '/api/users/admin/{userId}/add'

#### Опис

Створює нового користувача від імені адміністратора.

#### Параметри запиту
Path:
- userId (Long): Ідентифікатор адміністратора, що виконує дію.

Body:
- firstName (String): Ім'я користувача.
- lastName (String): Призвище користувача.
- role (String): Роль користувача.
- accessRights (Access): Права доступу (READ_FULL, READ_ONLY, FULL).
- login (String): Логін користувача (електронна пошта).
- password (String): Пароль користувача.

#### Відповідь

- 200 OK:
  - User (object): Об'єкт створеного користувача.
- 400 Bad Request:
  - message (string): Повідомлення про помилку у вхідних даних.
- 403 Forbidden:
  - message (string): Адміністратор не має прав для створення користувача.


### Get User by ID

**GET** '/api/users/{id}'

#### Опис

Отримує користувача за його унікальним ідентифікатором.

#### Параметри запиту
Path:
- id (Long): Ідентифікатор користувача.

#### Відповідь

- 200 OK:
  - User (object): Користувач за вказаним ідентифікатором.
- 404 Not Found:
  - message (string): Повідомлення про те, що користувач не знайдений.

# AuthController API

## Маршрути

### Login (User Login)

**POST** '/log/in'

#### Опис

Використовуються для входу користувача до системи. Використовує логін (електронну пошту) та пароль для автентифікації.

#### Параметри запиту
Body:
- login (String): Логін користувача (email).
- password (String): Пароль користувача.

#### Відповідь 

- 200 OK:
  - message (string): Повідомлення про успішний вхід "Вхід успішний. Ваш ID: [userID]".
- 401 Unauthorized:
  - message (string): Повідомлення про невірні облікові дані.

### Logout (User Logout)

**POST** '/log/out'

#### Опис

Використовуються для виходу користувача з системи, закінчуючи сесію.

#### Параметри запиту
Query:
- userId (Long): Ідентифікатор користувача, який виходить.

#### Відповідь 

- 200 OK:
  - message (string): Повідомлення про успішний вихід "Вихід успішний".
 
# Моделі даних

## BiologicalMaterial
Модель для біологічного матеріалу.

- `materialID` - Унікальний ідентифікатор біологічного матеріалу
- `materialName` - Назва біологічного матеріалу (від 2 до 100 символів)
- `expirationDate` - Дата закінчення терміну придатності біологічного матеріалу (має бути у майбутньому)
- `status` - Статус пожертвування (потрібно вказати статус пожертвування: `AVAILABLE`, `COLLECTED`, `DONATED`, `PENDING` `DISPOSED` )
- `transferDate` - Дата передачі матеріалу (має бути в минулому або поточному часі)
- `idealTemperature` - Ідеальна температура зберігання
- `idealOxygenLevel` - Ідеальний рівень кисню
- `idealHumidity` - Ідеальна вологість
- `donorID` - Ідентифікатор донора, що надав біологічний матеріал (не може бути порожнім)

## Donor
Модель для донора біологічного матеріалу.

- `donorID` - Унікальний ідентифікатор донора
- `firstName` - Ім'я донора (від 2 до 100 символів)
- `lastName` - Прізвище донора (від 2 до 100 символів)
- `birthDate` - Дата народження донора (має бути в минулому)
- `gender` - Стать донора (`MALE`, `FEMALE`)
- `idNumber` - Ідентифікаційний номер донора (10 символів, алфавітно-цифровий формат)
- `bloodType` - Група крові донора (наприклад, `A_POS`, `O_NEG`)
- `transplantRestrictions` - Обмеження на трансплантацію (не більше 500 символів)

## EventLog
Модель для запису дій користувача в системі.

- `eventLogID` - Унікальний ідентифікатор запису події
- `actionDetails` - Опис дії користувача (від 2 до 1000 символів)
- `actionTime` - Час виконання дії (має бути в минулому або поточному часі)
- `creatorID` - Ідентифікатор користувача, що виконав дію (може бути порожнім)

## Notification
Модель для сповіщення про події в системі.
- `notificationID` - Унікальний ідентифікатор сповіщення
- `eventType` - Тип події (від 2 до 100 символів)
- `details` - Опис події (від 5 до 500 символів)
- `materialID` - Ідентифікатор біологічного матеріалу, пов'язаного з подією (не може бути порожнім)

## StorageCondition
Модель для умов зберігання біологічного матеріалу.
- `recordID` - Унікальний ідентифікатор запису умов зберігання
- `temperature` - Температура (від -100 до 100 градусів, не може бути порожнім)
- `oxygenLevel` - Рівень кисню (від 0 до 100%, не може бути порожнім)
- `humidity` - Вологість (від 0 до 100%, не може бути порожнім)
- `measurementTime` - Час вимірювання (має бути в минулому або поточному часі)
- `zone` - Зона зберігання (тип: StorageZone)
- `materialID` - Ідентифікатор біологічного матеріалу, до якого відносяться умови зберігання (не може бути порожнім)

## User
Модель для користувача системи.
- `userID` - Унікальний ідентифікатор користувача
- `firstName` - Ім'я користувача (від 2 до 255 символів)
- `lastName` - Призвище користувача (від 2 до 255 символів)
- `role` - Роль користувача (від 2 до 255 символів)
- `accessRights` - Права доступу користувача (можливі значення: `FULL`, `READ_ALL`, `READ_ONLY`)
- `login` - Логін користувача (електронна пошта, від 2 до 100 символів)
- `password` - Пароль користувача (не менше 6 символів)
