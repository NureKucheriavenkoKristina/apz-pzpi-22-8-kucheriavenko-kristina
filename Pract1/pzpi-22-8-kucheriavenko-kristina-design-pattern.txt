Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії
 






Практична робота №1
з дисципліни: «Архітектура програмного забезпечення»
 





 
Виконала: 								Перевірив:
ст. гр. ПЗПІ-22-8							Ст. в. Сокорчук І. П. 
Кучерявенко К. Р.

                                                					




Харків 2025

1 ПАТЕРНИ ПРОЄКТУВАННЯ
1.1 Історія змін


	Зміни в документі нотуються до таблиці 1.1.	

Таблиця 1.1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	17.03.25	0.1	Створено розділ «Історія змін»
2	17.03.25	0.1	Створено розділ «Завдання до практичної роботи»
3	17.03.25	0.1	Створено розділ «Опис виконаної роботи»
4	17.03.25	0.1	Створено розділ «Висновки»
5	17.03.25	0.1	Додано додаток А з посиланням на відеоролик
6	17.03.25	0.1	Додано додаток Б зі слайдами презентації
7	17.03.25	0.1	Додано додаток В з програмним кодом
			
			
			



1.2 Завдання до практичної роботи


Завдання до практичної роботи полягає в ознайомленні з патерном проєктування «Декоратор» та його принципами використання в об'єктно-орієнтованому програмуванні. Необхідно дослідити, як цей підхід дозволяє розширювати функціональність класів без внесення змін у їх кодову базу, що забезпечує гнучкість і модульність програмного забезпечення. У межах роботи слід реалізувати власний приклад застосування декоратора, наприклад, для обробки текстових повідомлень або розширення можливостей певного об'єкта. Також важливо продемонструвати практичне використання цього патерна та пояснити його переваги порівняно з іншими способами розширення функціональності.

1.3 Опис виконаної роботи

Патерн «Декоратор» дозволяє додавати нову функціональність до об'єктів динамічно, не змінюючи їхнього початкового коду. Коли програмне забезпечення стає все більш складним і багатофункціональним, особливо важливо знаходити рішення, які дозволяють підтримувати гнучкість і масштабованість систем.
Патерн "Декоратор" широко використовується у багатьох сферах, зокрема в розробці графічних інтерфейсів, потокового введення-виведення, веб-додатків та багатьох інших напрямках. Він дозволяє модифікувати поведінку об'єктів під час виконання програми, що робить його надзвичайно ефективним підходом у складних програмних архітектурах. Завдяки такому підходу розробники можуть уникати дублювання коду та створювати більш гнучкі та розширювані системи. Наведемо основні проблеми, які вирішує цей патерн.
Динамічне додавання поведінки – часто буває так, що функціональність об'єкта потрібно розширити вже після створення екземпляра класу. Традиційний підхід через наслідування має певні обмеження, оскільки всі можливі комбінації повинні бути передбачені заздалегідь. Використовуючи «Декоратор», можна легко додавати або змінювати поведінку об'єкта без необхідності змінювати його базовий код.
Уникнення розростання коду – якщо для кожного нового варіанту поведінки створювати окремий підклас, це призводить до значного ускладнення структури коду. «Декоратор» дозволяє уникнути цієї проблеми, додаючи нові можливості без створення великої кількості підкласів. Це особливо важливо при розробці складних систем, де необхідно зберігати чистоту та підтримуваність коду.
Гнучке розширення функціоналу – завдяки «Декоратору» ми можемо розширювати можливості об'єкта поступово, додаючи нові компоненти лише тоді, коли це необхідно. Це особливо корисно у великих проєктах, де передбачити всі можливі сценарії використання заздалегідь складно. Гнучкість цього підходу дозволяє створювати програмні рішення, які легко адаптуються до нових вимог.
	Патерн "Декоратор" дозволяє додавати нові функціональності до об'єктів, не змінюючи їхнього коду. Його структура складається з кількох основних компонентів, кожен з яких відіграє свою роль у реалізації патерна.
Перше в структурі — це Component, який може бути як інтерфейсом, так і абстрактним класом. Він визначає базову функціональність, яку можна розширювати через інші класи. Цей компонент є основою для всіх інших елементів і задає стандарт, який має бути дотриманий.
Далі йде ConcreteComponent. Це клас, який реалізує інтерфейс або абстрактний клас Component і є об'єктом, до якого додаються нові можливості. Це той самий базовий об'єкт, на якому в подальшому будуть виконуватися зміни через декоратори.
Наступним елементом є Decorator. Це абстрактний клас, який також реалізує інтерфейс Component. Однак, окрім цього, він містить посилання на інший об'єкт типу Component. Це дозволяє вкладати декоратори один в інший, створюючи ланцюжок змін, який можна комбінувати для досягнення потрібного результату.
І ConcreteDecorator — це конкретні реалізації декораторів, які додають нову функціональність до об'єкта. Вони дозволяють створювати складні об'єкти з багатошаровими змінами, при цьому не змінюючи початкову реалізацію об'єкта. Це дозволяє підтримувати гнучкість і зручність в розширенні можливостей об'єктів без необхідності втручатися в їхній базовий код.
Завдяки такій структурі патерн «Декоратор» дозволяє гнучко додавати функціональність об'єктам, зберігаючи їхню основну логіку недоторканою і даючи можливість безпечного розширення.	


У даному прикладі використано патерн "Декоратор" для розширення функціональності базового об'єкта без зміни його структури. Спочатку визначено інтерфейс (рядки 1-4), який описує поведінку базового об'єкта. Далі реалізовано основний клас (рядки 6-12), який містить базову логіку.
Щоб мати можливість розширювати функціональність, створено абстрактний клас-декоратор (рядки 14-26), який зберігає посилання на базовий об'єкт і реалізує його інтерфейс. Конкретні декоратори, такі як додавання молока (рядки 27-37) та цукру (рядки 39-49), перевизначають метод і змінюють поведінку, додаючи додаткові можливості.
На етапі тестування (рядки 50-65) демонструється, як базовий об'єкт може бути поступово розширений за допомогою декораторів, що дозволяє гнучко комбінувати можливості без створення нових підкласів.
	Патерн «Декоратор» має кілька важливих переваг, завдяки яким він стає корисним інструментом при розробці програмного забезпечення.
Однією з основних переваг є гнучкість. Завдяки можливості комбінувати декоратори в різних варіаціях, можна створювати унікальні конфігурації об'єктів. Це дозволяє додавати функціональність до об'єктів у будь-якому порядку, створюючи таким чином адаптивні й гнучкі рішення.
Ще однією важливою перевагою є дотримання принципу відкритості/закритості. Патерн дозволяє розширювати функціональність об'єктів без необхідності змінювати їхній початковий код. Це забезпечує стійкість до змін і спрощує подальше розширення програмного забезпечення, оскільки нові можливості можуть бути додані через декоратори, а не через зміну базових класів.
Модульність є ще однією значною перевагою «Декоратора». Відповідальність за різні аспекти функціональності розподіляється між окремими класами, що спрощує тестування та супровід коду. Це дозволяє кожному декоратору мати свою чітко визначену задачу і полегшує виявлення та усунення помилок.
Останнім, але не менш важливим, є аспект легкої інтеграції. Патерн «Декоратор» можна легко застосовувати в різних архітектурних підходах, що забезпечує зручність при розширенні систем. Його можна використовувати як в малих, так і в великих проектах, де потрібно додавати нові функціональні можливості без порушення загальної структури.
Таким чином, «Декоратор» надає можливість створювати потужні й гнучкі системи, що легко модифікуються та розширюються. Попри численні переваги, патерн «Декоратор» має й кілька недоліків, які можуть виникнути при його використанні.
Першим з таких недоліків є складність розуміння коду. Коли в системі використовується велика кількість декораторів, кожен з яких додає нову функціональність, це може значно ускладнити відстежування поведінки об'єктів. В результаті, для розуміння, як працює система, потрібно враховувати не тільки основний об'єкт, але й всі його декоратори, що може бути досить складним завданням.
Іншим важливим недоліком є проблеми з порядком виклику декораторів. Оскільки декоратори можуть бути вкладені один в одного, неправильний порядок їх застосування може спричинити небажані або непередбачувані ефекти. У випадку, якщо декоратори змінюють одну й ту ж властивість або функціональність, важливо ретельно продумати, в якому порядку їх застосовувати, інакше результат може бути не таким, як очікувалося.
Останнім недоліком є збільшена кількість класів. Використання декораторів часто призводить до створення великої кількості допоміжних класів, що в свою чергу може ускладнити структуру проекту. Замість одного класу, який відповідає за певну функціональність, можуть виникнути десятки допоміжних класів, що потребують підтримки й додаткової документації. Це може вплинути на зручність супроводу та розширення системи в майбутньому.
Загалом, хоча патерн «Декоратор» надає велику гнучкість і модульність, його використання вимагає обережності та ретельного планування, щоб уникнути зазначених проблем.
	Існують кілька альтернатив патерну «Декоратор», кожна з яких має свої переваги та недоліки в залежності від конкретних вимог і контексту застосування.
Наслідування — це один з найбільш базових способів розширення функціональності об'єкта. Через наслідування можна створювати нові класи, що доповнюють або змінюють поведінку базових класів. Хоча наслідування є менш гнучким у порівнянні з «Декоратором», оскільки воно не дозволяє змінювати поведінку об'єкта без створення нових класів, воно простіше у використанні та часто є природним вибором для простих випадків.
Стратегія (Strategy) — цей патерн дозволяє змінювати алгоритм або поведінку об'єкта під час виконання програми. Замість того, щоб модифікувати сам об'єкт, ми створюємо різні стратегії і передаємо їх об'єкту для виконання. Патерн «Стратегія» дозволяє змінювати алгоритми на ходу, а отже, є корисним, коли потрібно обирати між кількома варіантами поведінки в залежності від контексту, що може бути більш зручним в порівнянні з «Декоратором» у деяких ситуаціях.
Ланцюг обов’язків (Chain of Responsibility) — цей патерн використовується для передачі запиту між кількома обробниками. Кожен обробник в ланцюгу має можливість або обробити запит, або передати його наступному обробнику. Це дозволяє створювати гнучкі структури для обробки запитів, де не потрібно явно вказувати, який саме обробник має виконати певну дію. Ланцюг обов’язків часто застосовується для ситуацій, коли існує необхідність у серії кроків або операцій, але кожен з них може бути виконаний окремо в залежності від умов.
Таким чином, кожна з цих альтернатив має свої особливості та підходить для різних типів задач. Вибір між ними залежить від конкретних вимог проекту та того, яку саме задачу потрібно вирішити.
У Java та інших технологіях є багато можливостей для використання патерну «Декоратор», щоб додати нові функціональності до існуючих об'єктів або компонентів, без зміни їхньої базової реалізації. 
Java є багато класів для роботи з потоками вводу/виводу, таких як InputStream, BufferedInputStream і DataInputStream. Кожен з цих класів може бути використаний для додавання додаткових функцій, таких як буферизація або читання специфічних типів даних. Наприклад, можна обгорнути базовий потік InputStream у BufferedInputStream, що дозволяє зменшити кількість операцій введення-виведення, збільшуючи ефективність читання. В цьому випадку патерн «Декоратор» допомагає додавати нові можливості без зміни основного потоку.
При розробці графічних інтерфейсів користувача (GUI) можна застосовувати декоратори для додавання нових графічних ефектів або функціональності до елементів інтерфейсу. Наприклад, можна обгорнути стандартні компоненти, такі як кнопки або панелі, у декоратори, які додають нові ефекти, як анімація, зміна кольору при наведенні миші або тіні. Це дозволяє змінювати вигляд та поведінку елементів GUI без необхідності змінювати основний код компонента.
У веб-серверах, зокрема у Spring Boot, можна використовувати патерн «Декоратор» для обгортання запитів в middleware (проміжний шар). Middleware дозволяє додавати різні функціональності до обробки запитів, такі як логування, автентифікація, кешування або обробка помилок. Завдяки використанню декораторів, ці функціональності можна додавати в системи без необхідності змінювати основний код обробки запитів.
Для захисту переданих даних можна використовувати патерн «Декоратор», щоб додати додаткові рівні безпеки через шифрування. Наприклад, можна обгорнути потік вводу/виводу в декоратор, який автоматично шифрує або дешифрує дані при їх передачі або зберіганні. Це дозволяє забезпечити додатковий рівень захисту без необхідності змінювати основний код передачі даних.
Таким чином, патерн «Декоратор» дає змогу створювати гнучкі та розширювані рішення, додаючи нові функціональності до компонентів системи без зміни їхньої основної структури.
Патерн «Декоратор» дозволяє гнучко розширювати функціональність без змін у вихідному коді. Важливо використовувати його для динамічного додавання поведінки, уникаючи зайвого ускладнення структури. Кожен декоратор має чітко виконувати свою роль, щоб зберегти зрозумілість і підтримуваність коду.




1.4 Висновки


Патерн "Декоратор" є потужним інструментом для розширення можливостей об'єктів без зміни їхньої початкової реалізації. Він дозволяє уникнути недоліків, пов'язаних із глибокою ієрархією наслідування, та забезпечує більшу гнучкість і масштабованість програмного забезпечення. Однак його використання потребує ретельного планування, оскільки велика кількість вкладених об'єктів може ускладнити розуміння коду. Використовуючи цей патерн, можна суттєво покращити архітектуру програмних систем і підвищити їхню адаптивність до змін.

 
Додаток А
Хронологічний опис та посилання


Відеозапис доповіді на YouTube: https://youtu.be/HXId2JTm6wA

Хронологічний опис доповіді:
00:00 Вступна частина: представлення теми презентації
Короткий вступ, у якому пояснюється, про що буде презентація, чому ця тема є актуальною та які питання будуть розглянуті.
00:09 Що таке патерн «Декоратор»
Визначення патерна «Декоратор», його ключові особливості та концепція. Пояснення, як він допомагає змінювати поведінку об'єктів без зміни їхнього початкового коду.
00:26 Основні проблеми, які вирішує «Декоратор»
Огляд ключових труднощів у проєктуванні програмного забезпечення, які можна вирішити за допомогою цього патерна, зокрема: динамічне розширення функціоналу, уникнення розростання підкласів та покращення підтримуваності коду.
01:58 Які основні компоненти?
Опис структурних елементів патерна: базовий клас (компонент), конкретні реалізації та декоратори. Пояснення, як вони взаємодіють між собою.
03:31 Спрощена демонстрація патерна
Приклад базової реалізації патерна «Декоратор» з поясненням основних кроків: створення базового компонента, огортання його в декоратори та додавання нової поведінки.
04:24 Чому варто використовувати «Декоратор»?
Основні переваги патерна: гнучкість, зменшення дублювання коду, динамічне розширення можливостей об'єктів, збереження принципу відкритості/закритості.
05:57 Коли «Декоратор» не підходить?
Огляд ситуацій, коли використання цього патерна може бути недоречним або ускладнювати код. Наприклад, якщо є занадто багато рівнів вкладеності, що ускладнює розуміння коду, або якщо зміни можна реалізувати простішими методами.
07:12 Альтернативи «Декоратору»
Розгляд інших підходів, які можна використовувати замість «Декоратора», таких як наслідування, стратегія чи аспектно-орієнтоване програмування. Порівняння їхніх сильних і слабких сторін.
08:46 Застосування у стандартних бібліотеках
Реальні приклади використання патерна «Декоратор» у стандартних бібліотеках мов програмування, зокрема в Java (I/O Streams), тощо.
11:07 Рекомендації щодо використання
Коротко про рекомендації щодо використання даного патерна. 
11:23 Висновки
Підсумок основних ідей презентації: ключові переваги «Декоратора», коли його варто застосовувати та в яких випадках краще використовувати інші підходи. Заключні думки та можливі напрямки для подальшого вивчення.  
Додаток Б
Слайди презентації доповіді


 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Проблеми, які вирішує даний патерн
 
	Рисунок Б.3 – Структура патерну

 
Рисунок Б.4 – Реалізація патерну
 
Рисунок Б.5 – Приклад коду з використанням патерну 

 
Рисунок Б.6 – Продовження прикладу 
 
	Рисунок Б.7 – Переваги патерну

 
Рисунок Б.8 – Недоліки патерну
 
Рисунок Б.9 – Альтернативи патерну

 
Рисунок Б.10 – Приклади використання патерну
 
Рисунок Б.11 – Рекомендації щодо використання патерну

 
Рисунок Б.12 – Висновки
 
Рисунок Б.13 – Використані джерела


 
Додаток В
Приклад реалізації патерну на мові Java


1. // 1. Базовий інтерфейс Component  
2. public interface Coffee {  
3.     double cost();  // Метод для отримання вартості  
4. }  
5.  
6. // 2. ConcreteComponent - реалізація основного об'єкта  
7. public class SimpleCoffee implements Coffee {  
8.     @Override  
9.     public double cost() {  
10.         return 5.0;  // Вартість звичайної кави  
11.     }  
12. }  
13.  
14. // 3. Абстрактний клас Decorator  
15. public abstract class CoffeeDecorator implements Coffee {  
16.     protected Coffee decoratedCoffee;  
17.  
18.     public CoffeeDecorator(Coffee coffee) {  
19.         this.decoratedCoffee = coffee;  
20.     }  
21.  
22.     @Override  
23.     public double cost() {  
24.         return decoratedCoffee.cost();  // Виклик методу в базовому класі  
25.     }  
26. }
27. // 4. ConcreteDecorator для молока  
28. public class MilkDecorator extends CoffeeDecorator {  
29.     public MilkDecorator(Coffee coffee) {  
30.         super(coffee);  
31.     }  
32.  
33.     @Override  
34.     public double cost() {  
35.         return decoratedCoffee.cost() + 1.5;  // Додаємо вартість молока  
36.     }  
37. }  
38.  
39. // 5. ConcreteDecorator для цукру  
40. public class SugarDecorator extends CoffeeDecorator {  
41.     public SugarDecorator(Coffee coffee) {  
42.         super(coffee);  
43.     }  
44.  
45.     @Override  
46.     public double cost() {  
47.         return decoratedCoffee.cost() + 0.5;  // Додаємо вартість цукру  
48.     }  
49. }
50. // 6. Тестування патерну  
51. public class DecoratorPatternTest {  
52.     public static void main(String[] args) {  
53.         // Створення простого об'єкта кави  
54.         Coffee coffee = new SimpleCoffee();  
55.         System.out.println("Cost of simple coffee: " + coffee.cost());  
56.  
57.         // Додавання молока  
58.         coffee = new MilkDecorator(coffee);  
59.         System.out.println("Cost of coffee with milk: " + coffee.cost());  
60.  
61.         // Додавання цукру  
62.         coffee = new SugarDecorator(coffee);  
63.         System.out.println("Cost of coffee with milk and sugar: " + coffee.cost());  
64.     }  
65. }
